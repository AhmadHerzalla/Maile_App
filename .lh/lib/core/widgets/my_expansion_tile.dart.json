{
    "sourceFile": "lib/core/widgets/my_expansion_tile.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1694523077362,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1694523118403,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,786 @@\n+// Copyright 2014 The Flutter Authors. All rights reserved.\r\n+// Use of this source code is governed by a BSD-style license that can be\r\n+// found in the LICENSE file.\r\n+\r\n+import 'package:flutter/widgets.dart';\r\n+\r\n+import 'color_scheme.dart';\r\n+import 'colors.dart';\r\n+import 'expansion_tile_theme.dart';\r\n+import 'icons.dart';\r\n+import 'list_tile.dart';\r\n+import 'list_tile_theme.dart';\r\n+import 'material.dart';\r\n+import 'theme.dart';\r\n+\r\n+const Duration _kExpand = Duration(milliseconds: 200);\r\n+\r\n+/// Enables control over a single [YExpansionTile]'s expanded/collapsed state.\r\n+///\r\n+/// It can be useful to expand or collapse an [YExpansionTile]\r\n+/// programatically, for example to reconfigure an existing expansion\r\n+/// tile based on a system event. To do so, create an [YExpansionTile]\r\n+/// with an [YExpansionTileController] that's owned by a stateful widget\r\n+/// or look up the tile's automatically created [YExpansionTileController]\r\n+/// with [YExpansionTileController.of]\r\n+///\r\n+/// The controller's [expand] and [collapse] methods cause the\r\n+/// the [YExpansionTile] to rebuild, so they may not be called from\r\n+/// a build method.\r\n+class YExpansionTileController {\r\n+  /// Create a controller to be used with [YExpansionTile.controller].\r\n+  YExpansionTileController();\r\n+\r\n+  _YExpansionTileState? _state;\r\n+\r\n+  /// Whether the [YExpansionTile] built with this controller is in expanded state.\r\n+  ///\r\n+  /// This property doesn't take the animation into account. It reports `true`\r\n+  /// even if the expansion animation is not completed.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [expand], which expands the [YExpansionTile].\r\n+  ///  * [collapse], which collapses the [YExpansionTile].\r\n+  ///  * [YExpansionTile.controller] to create an YExpansionTile with a controller.\r\n+  bool get isExpanded {\r\n+    assert(_state != null);\r\n+    return _state!._isExpanded;\r\n+  }\r\n+\r\n+  /// Expands the [YExpansionTile] that was built with this controller;\r\n+  ///\r\n+  /// Normally the tile is expanded automatically when the user taps on the header.\r\n+  /// It is sometimes useful to trigger the expansion programmatically due\r\n+  /// to external changes.\r\n+  ///\r\n+  /// If the tile is already in the expanded state (see [isExpanded]), calling\r\n+  /// this method has no effect.\r\n+  ///\r\n+  /// Calling this method may cause the [YExpansionTile] to rebuild, so it may\r\n+  /// not be called from a build method.\r\n+  ///\r\n+  /// Calling this method will trigger an [YExpansionTile.onExpansionChanged] callback.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [collapse], which collapses the tile.\r\n+  ///  * [isExpanded] to check whether the tile is expanded.\r\n+  ///  * [YExpansionTile.controller] to create an YExpansionTile with a controller.\r\n+  void expand() {\r\n+    assert(_state != null);\r\n+    if (!isExpanded) {\r\n+      _state!._toggleExpansion();\r\n+    }\r\n+  }\r\n+\r\n+  /// Collapses the [YExpansionTile] that was built with this controller.\r\n+  ///\r\n+  /// Normally the tile is collapsed automatically when the user taps on the header.\r\n+  /// It can be useful sometimes to trigger the collapse programmatically due\r\n+  /// to some external changes.\r\n+  ///\r\n+  /// If the tile is already in the collapsed state (see [isExpanded]), calling\r\n+  /// this method has no effect.\r\n+  ///\r\n+  /// Calling this method may cause the [YExpansionTile] to rebuild, so it may\r\n+  /// not be called from a build method.\r\n+  ///\r\n+  /// Calling this method will trigger an [YExpansionTile.onExpansionChanged] callback.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [expand], which expands the tile.\r\n+  ///  * [isExpanded] to check whether the tile is expanded.\r\n+  ///  * [YExpansionTile.controller] to create an YExpansionTile with a controller.\r\n+  void collapse() {\r\n+    assert(_state != null);\r\n+    if (isExpanded) {\r\n+      _state!._toggleExpansion();\r\n+    }\r\n+  }\r\n+\r\n+  /// Finds the [YExpansionTileController] for the closest [YExpansionTile] instance\r\n+  /// that encloses the given context.\r\n+  ///\r\n+  /// If no [YExpansionTile] encloses the given context, calling this\r\n+  /// method will cause an assert in debug mode, and throw an\r\n+  /// exception in release mode.\r\n+  ///\r\n+  /// To return null if there is no [YExpansionTile] use [maybeOf] instead.\r\n+  ///\r\n+  /// {@tool dartpad}\r\n+  /// Typical usage of the [YExpansionTileController.of] function is to call it from within the\r\n+  /// `build` method of a descendant of an [YExpansionTile].\r\n+  ///\r\n+  /// When the [YExpansionTile] is actually created in the same `build`\r\n+  /// function as the callback that refers to the controller, then the\r\n+  /// `context` argument to the `build` function can't be used to find\r\n+  /// the [YExpansionTileController] (since it's \"above\" the widget\r\n+  /// being returned in the widget tree). In cases like that you can\r\n+  /// add a [Builder] widget, which provides a new scope with a\r\n+  /// [BuildContext] that is \"under\" the [YExpansionTile]:\r\n+  ///\r\n+  /// ** See code in examples/api/lib/material/expansion_tile/expansion_tile.1.dart **\r\n+  /// {@end-tool}\r\n+  ///\r\n+  /// A more efficient solution is to split your build function into\r\n+  /// several widgets. This introduces a new context from which you\r\n+  /// can obtain the [YExpansionTileController]. With this approach you\r\n+  /// would have an outer widget that creates the [YExpansionTile]\r\n+  /// populated by instances of your new inner widgets, and then in\r\n+  /// these inner widgets you would use [YExpansionTileController.of].\r\n+  static YExpansionTileController of(BuildContext context) {\r\n+    final _YExpansionTileState? result =\r\n+        context.findAncestorStateOfType<_YExpansionTileState>();\r\n+    if (result != null) {\r\n+      return result._tileController;\r\n+    }\r\n+    throw FlutterError.fromParts(<DiagnosticsNode>[\r\n+      ErrorSummary(\r\n+        'YExpansionTileController.of() called with a context that does not contain a YExpansionTile.',\r\n+      ),\r\n+      ErrorDescription(\r\n+        'No YExpansionTile ancestor could be found starting from the context that was passed to YExpansionTileController.of(). '\r\n+        'This usually happens when the context provided is from the same StatefulWidget as that '\r\n+        'whose build function actually creates the YExpansionTile widget being sought.',\r\n+      ),\r\n+      ErrorHint(\r\n+        'There are several ways to avoid this problem. The simplest is to use a Builder to get a '\r\n+        'context that is \"under\" the YExpansionTile. For an example of this, please see the '\r\n+        'documentation for YExpansionTileController.of():\\n'\r\n+        '  https://api.flutter.dev/flutter/material/YExpansionTile/of.html',\r\n+      ),\r\n+      ErrorHint(\r\n+        'A more efficient solution is to split your build function into several widgets. This '\r\n+        'introduces a new context from which you can obtain the YExpansionTile. In this solution, '\r\n+        'you would have an outer widget that creates the YExpansionTile populated by instances of '\r\n+        'your new inner widgets, and then in these inner widgets you would use YExpansionTileController.of().\\n'\r\n+        'An other solution is assign a GlobalKey to the YExpansionTile, '\r\n+        'then use the key.currentState property to obtain the YExpansionTile rather than '\r\n+        'using the YExpansionTileController.of() function.',\r\n+      ),\r\n+      context.describeElement('The context used was'),\r\n+    ]);\r\n+  }\r\n+\r\n+  /// Finds the [YExpansionTile] from the closest instance of this class that\r\n+  /// encloses the given context and returns its [YExpansionTileController].\r\n+  ///\r\n+  /// If no [YExpansionTile] encloses the given context then return null.\r\n+  /// To throw an exception instead, use [of] instead of this function.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [of], a similar function to this one that throws if no [YExpansionTile]\r\n+  ///    encloses the given context. Also includes some sample code in its\r\n+  ///    documentation.\r\n+  static YExpansionTileController? maybeOf(BuildContext context) {\r\n+    return context\r\n+        .findAncestorStateOfType<_YExpansionTileState>()\r\n+        ?._tileController;\r\n+  }\r\n+}\r\n+\r\n+/// A single-line [ListTile] with an expansion arrow icon that expands or collapses\r\n+/// the tile to reveal or hide the [children].\r\n+///\r\n+/// This widget is typically used with [ListView] to create an\r\n+/// \"expand / collapse\" list entry. When used with scrolling widgets like\r\n+/// [ListView], a unique [PageStorageKey] must be specified to enable the\r\n+/// [YExpansionTile] to save and restore its expanded state when it is scrolled\r\n+/// in and out of view.\r\n+///\r\n+/// This class overrides the [ListTileThemeData.iconColor] and [ListTileThemeData.textColor]\r\n+/// theme properties for its [ListTile]. These colors animate between values when\r\n+/// the tile is expanded and collapsed: between [iconColor], [collapsedIconColor] and\r\n+/// between [textColor] and [collapsedTextColor].\r\n+///\r\n+/// The expansion arrow icon is shown on the right by default in left-to-right languages\r\n+/// (i.e. the trailing edge). This can be changed using [controlAffinity]. This maps\r\n+/// to the [leading] and [trailing] properties of [YExpansionTile].\r\n+///\r\n+/// {@tool dartpad}\r\n+/// This example demonstrates how the [YExpansionTile] icon's location and appearance\r\n+/// can be customized.\r\n+///\r\n+/// ** See code in examples/api/lib/material/expansion_tile/expansion_tile.0.dart **\r\n+/// {@end-tool}\r\n+///\r\n+/// {@tool dartpad}\r\n+/// This example demonstrates how an [YExpansionTileController] can be used to\r\n+/// programatically expand or collapse an [YExpansionTile].\r\n+///\r\n+/// ** See code in examples/api/lib/material/expansion_tile/expansion_tile.1.dart **\r\n+/// {@end-tool}\r\n+///\r\n+/// See also:\r\n+///\r\n+///  * [ListTile], useful for creating expansion tile [children] when the\r\n+///    expansion tile represents a sublist.\r\n+///  * The \"Expand and collapse\" section of\r\n+///    <https://material.io/components/lists#types>\r\n+class YExpansionTile extends StatefulWidget {\r\n+  /// Creates a single-line [ListTile] with an expansion arrow icon that expands or collapses\r\n+  /// the tile to reveal or hide the [children]. The [initiallyExpanded] property must\r\n+  /// be non-null.\r\n+  const YExpansionTile({\r\n+    super.key,\r\n+    this.leading,\r\n+    required this.title,\r\n+    this.subtitle,\r\n+    this.onExpansionChanged,\r\n+    this.children = const <Widget>[],\r\n+    this.trailing,\r\n+    this.initiallyExpanded = false,\r\n+    this.maintainState = false,\r\n+    this.tilePadding,\r\n+    this.expandedCrossAxisAlignment,\r\n+    this.expandedAlignment,\r\n+    this.childrenPadding,\r\n+    this.backgroundColor,\r\n+    this.collapsedBackgroundColor,\r\n+    this.textColor,\r\n+    this.collapsedTextColor,\r\n+    this.iconColor,\r\n+    this.collapsedIconColor,\r\n+    this.shape,\r\n+    this.collapsedShape,\r\n+    this.clipBehavior,\r\n+    this.controlAffinity,\r\n+    this.controller,\r\n+  }) : assert(\r\n+          expandedCrossAxisAlignment != CrossAxisAlignment.baseline,\r\n+          'CrossAxisAlignment.baseline is not supported since the expanded children '\r\n+          'are aligned in a column, not a row. Try to use another constant.',\r\n+        );\r\n+\r\n+  /// A widget to display before the title.\r\n+  ///\r\n+  /// Typically a [CircleAvatar] widget.\r\n+  ///\r\n+  /// Depending on the value of [controlAffinity], the [leading] widget\r\n+  /// may replace the rotating expansion arrow icon.\r\n+  final Widget? leading;\r\n+\r\n+  /// The primary content of the list item.\r\n+  ///\r\n+  /// Typically a [Text] widget.\r\n+  final Widget title;\r\n+\r\n+  /// Additional content displayed below the title.\r\n+  ///\r\n+  /// Typically a [Text] widget.\r\n+  final Widget? subtitle;\r\n+\r\n+  /// Called when the tile expands or collapses.\r\n+  ///\r\n+  /// When the tile starts expanding, this function is called with the value\r\n+  /// true. When the tile starts collapsing, this function is called with\r\n+  /// the value false.\r\n+  final ValueChanged<bool>? onExpansionChanged;\r\n+\r\n+  /// The widgets that are displayed when the tile expands.\r\n+  ///\r\n+  /// Typically [ListTile] widgets.\r\n+  final List<Widget> children;\r\n+\r\n+  /// The color to display behind the sublist when expanded.\r\n+  ///\r\n+  /// If this property is null then [YExpansionTileThemeData.backgroundColor] is used. If that\r\n+  /// is also null then Colors.transparent is used.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [YExpansionTileTheme.of], which returns the nearest [YExpansionTileTheme]'s\r\n+  ///   [YExpansionTileThemeData].\r\n+  final Color? backgroundColor;\r\n+\r\n+  /// When not null, defines the background color of tile when the sublist is collapsed.\r\n+  ///\r\n+  /// If this property is null then [YExpansionTileThemeData.collapsedBackgroundColor] is used.\r\n+  /// If that is also null then Colors.transparent is used.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [YExpansionTileTheme.of], which returns the nearest [YExpansionTileTheme]'s\r\n+  ///   [YExpansionTileThemeData].\r\n+  final Color? collapsedBackgroundColor;\r\n+\r\n+  /// A widget to display after the title.\r\n+  ///\r\n+  /// Depending on the value of [controlAffinity], the [trailing] widget\r\n+  /// may replace the rotating expansion arrow icon.\r\n+  final Widget? trailing;\r\n+\r\n+  /// Specifies if the list tile is initially expanded (true) or collapsed (false, the default).\r\n+  final bool initiallyExpanded;\r\n+\r\n+  /// Specifies whether the state of the children is maintained when the tile expands and collapses.\r\n+  ///\r\n+  /// When true, the children are kept in the tree while the tile is collapsed.\r\n+  /// When false (default), the children are removed from the tree when the tile is\r\n+  /// collapsed and recreated upon expansion.\r\n+  final bool maintainState;\r\n+\r\n+  /// Specifies padding for the [ListTile].\r\n+  ///\r\n+  /// Analogous to [ListTile.contentPadding], this property defines the insets for\r\n+  /// the [leading], [title], [subtitle] and [trailing] widgets. It does not inset\r\n+  /// the expanded [children] widgets.\r\n+  ///\r\n+  /// If this property is null then [YExpansionTileThemeData.tilePadding] is used. If that\r\n+  /// is also null then the tile's padding is `EdgeInsets.symmetric(horizontal: 16.0)`.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [YExpansionTileTheme.of], which returns the nearest [YExpansionTileTheme]'s\r\n+  ///   [YExpansionTileThemeData].\r\n+  final EdgeInsetsGeometry? tilePadding;\r\n+\r\n+  /// Specifies the alignment of [children], which are arranged in a column when\r\n+  /// the tile is expanded.\r\n+  ///\r\n+  /// The internals of the expanded tile make use of a [Column] widget for\r\n+  /// [children], and [Align] widget to align the column. The [expandedAlignment]\r\n+  /// parameter is passed directly into the [Align].\r\n+  ///\r\n+  /// Modifying this property controls the alignment of the column within the\r\n+  /// expanded tile, not the alignment of [children] widgets within the column.\r\n+  /// To align each child within [children], see [expandedCrossAxisAlignment].\r\n+  ///\r\n+  /// The width of the column is the width of the widest child widget in [children].\r\n+  ///\r\n+  /// If this property is null then [YExpansionTileThemeData.expandedAlignment]is used. If that\r\n+  /// is also null then the value of [expandedAlignment] is [Alignment.center].\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [YExpansionTileTheme.of], which returns the nearest [YExpansionTileTheme]'s\r\n+  ///   [YExpansionTileThemeData].\r\n+  final Alignment? expandedAlignment;\r\n+\r\n+  /// Specifies the alignment of each child within [children] when the tile is expanded.\r\n+  ///\r\n+  /// The internals of the expanded tile make use of a [Column] widget for\r\n+  /// [children], and the `crossAxisAlignment` parameter is passed directly into\r\n+  /// the [Column].\r\n+  ///\r\n+  /// Modifying this property controls the cross axis alignment of each child\r\n+  /// within its [Column]. The width of the [Column] that houses [children] will\r\n+  /// be the same as the widest child widget in [children]. The width of the\r\n+  /// [Column] might not be equal to the width of the expanded tile.\r\n+  ///\r\n+  /// To align the [Column] along the expanded tile, use the [expandedAlignment]\r\n+  /// property instead.\r\n+  ///\r\n+  /// When the value is null, the value of [expandedCrossAxisAlignment] is\r\n+  /// [CrossAxisAlignment.center].\r\n+  final CrossAxisAlignment? expandedCrossAxisAlignment;\r\n+\r\n+  /// Specifies padding for [children].\r\n+  ///\r\n+  /// If this property is null then [YExpansionTileThemeData.childrenPadding] is used. If that\r\n+  /// is also null then the value of [childrenPadding] is [EdgeInsets.zero].\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [YExpansionTileTheme.of], which returns the nearest [YExpansionTileTheme]'s\r\n+  ///   [YExpansionTileThemeData].\r\n+  final EdgeInsetsGeometry? childrenPadding;\r\n+\r\n+  /// The icon color of tile's expansion arrow icon when the sublist is expanded.\r\n+  ///\r\n+  /// Used to override to the [ListTileThemeData.iconColor].\r\n+  ///\r\n+  /// If this property is null then [YExpansionTileThemeData.iconColor] is used. If that\r\n+  /// is also null then the value of [ColorScheme.primary] is used.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [YExpansionTileTheme.of], which returns the nearest [YExpansionTileTheme]'s\r\n+  ///   [YExpansionTileThemeData].\r\n+  final Color? iconColor;\r\n+\r\n+  /// The icon color of tile's expansion arrow icon when the sublist is collapsed.\r\n+  ///\r\n+  /// Used to override to the [ListTileThemeData.iconColor].\r\n+  ///\r\n+  /// If this property is null then [YExpansionTileThemeData.collapsedIconColor] is used. If that\r\n+  /// is also null and [ThemeData.useMaterial3] is true, [ColorScheme.onSurface] is used. Otherwise,\r\n+  /// defaults to [ThemeData.unselectedWidgetColor] color.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [YExpansionTileTheme.of], which returns the nearest [YExpansionTileTheme]'s\r\n+  ///   [YExpansionTileThemeData].\r\n+  final Color? collapsedIconColor;\r\n+\r\n+  /// The color of the tile's titles when the sublist is expanded.\r\n+  ///\r\n+  /// Used to override to the [ListTileThemeData.textColor].\r\n+  ///\r\n+  /// If this property is null then [YExpansionTileThemeData.textColor] is used. If that\r\n+  /// is also null then and [ThemeData.useMaterial3] is true, color of the [TextTheme.bodyLarge]\r\n+  /// will be used for the [title] and [subtitle]. Otherwise, defaults to [ColorScheme.primary] color.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [YExpansionTileTheme.of], which returns the nearest [YExpansionTileTheme]'s\r\n+  ///   [YExpansionTileThemeData].\r\n+  final Color? textColor;\r\n+\r\n+  /// The color of the tile's titles when the sublist is collapsed.\r\n+  ///\r\n+  /// Used to override to the [ListTileThemeData.textColor].\r\n+  ///\r\n+  /// If this property is null then [YExpansionTileThemeData.collapsedTextColor] is used.\r\n+  /// If that is also null and [ThemeData.useMaterial3] is true, color of the\r\n+  /// [TextTheme.bodyLarge] will be used for the [title] and [subtitle]. Otherwise,\r\n+  /// defaults to color of the [TextTheme.titleMedium].\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [YExpansionTileTheme.of], which returns the nearest [YExpansionTileTheme]'s\r\n+  ///   [YExpansionTileThemeData].\r\n+  final Color? collapsedTextColor;\r\n+\r\n+  /// The tile's border shape when the sublist is expanded.\r\n+  ///\r\n+  /// If this property is null, the [YExpansionTileThemeData.shape] is used. If that\r\n+  /// is also null, a [Border] with vertical sides default to [ThemeData.dividerColor] is used\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [YExpansionTileTheme.of], which returns the nearest [YExpansionTileTheme]'s\r\n+  ///   [YExpansionTileThemeData].\r\n+  final ShapeBorder? shape;\r\n+\r\n+  /// The tile's border shape when the sublist is collapsed.\r\n+  ///\r\n+  /// If this property is null, the [YExpansionTileThemeData.collapsedShape] is used. If that\r\n+  /// is also null, a [Border] with vertical sides default to Color [Colors.transparent] is used\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [YExpansionTileTheme.of], which returns the nearest [YExpansionTileTheme]'s\r\n+  ///   [YExpansionTileThemeData].\r\n+  final ShapeBorder? collapsedShape;\r\n+\r\n+  /// {@macro flutter.material.Material.clipBehavior}\r\n+  ///\r\n+  /// If this property is null, the [YExpansionTileThemeData.clipBehavior] is used. If that\r\n+  /// is also null, a [Clip.none] is used\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [YExpansionTileTheme.of], which returns the nearest [YExpansionTileTheme]'s\r\n+  ///   [YExpansionTileThemeData].\r\n+  final Clip? clipBehavior;\r\n+\r\n+  /// Typically used to force the expansion arrow icon to the tile's leading or trailing edge.\r\n+  ///\r\n+  /// By default, the value of [controlAffinity] is [ListTileControlAffinity.platform],\r\n+  /// which means that the expansion arrow icon will appear on the tile's trailing edge.\r\n+  final ListTileControlAffinity? controlAffinity;\r\n+\r\n+  /// If provided, the controller can be used to expand and collapse tiles.\r\n+  ///\r\n+  /// In cases were control over the tile's state is needed from a callback triggered\r\n+  /// by a widget within the tile, [YExpansionTileController.of] may be more convenient\r\n+  /// than supplying a controller.\r\n+  final YExpansionTileController? controller;\r\n+\r\n+  @override\r\n+  State<YExpansionTile> createState() => _YExpansionTileState();\r\n+}\r\n+\r\n+class _YExpansionTileState extends State<YExpansionTile>\r\n+    with SingleTickerProviderStateMixin {\r\n+  static final Animatable<double> _easeOutTween =\r\n+      CurveTween(curve: Curves.easeOut);\r\n+  static final Animatable<double> _easeInTween =\r\n+      CurveTween(curve: Curves.easeIn);\r\n+  static final Animatable<double> _halfTween =\r\n+      Tween<double>(begin: 0.0, end: 0.5);\r\n+\r\n+  final ShapeBorderTween _borderTween = ShapeBorderTween();\r\n+  final ColorTween _headerColorTween = ColorTween();\r\n+  final ColorTween _iconColorTween = ColorTween();\r\n+  final ColorTween _backgroundColorTween = ColorTween();\r\n+\r\n+  late AnimationController _animationController;\r\n+  late Animation<double> _iconTurns;\r\n+  late Animation<double> _heightFactor;\r\n+  late Animation<ShapeBorder?> _border;\r\n+  late Animation<Color?> _headerColor;\r\n+  late Animation<Color?> _iconColor;\r\n+  late Animation<Color?> _backgroundColor;\r\n+\r\n+  bool _isExpanded = false;\r\n+  late YExpansionTileController _tileController;\r\n+\r\n+  @override\r\n+  void initState() {\r\n+    super.initState();\r\n+    _animationController = AnimationController(duration: _kExpand, vsync: this);\r\n+    _heightFactor = _animationController.drive(_easeInTween);\r\n+    _iconTurns = _animationController.drive(_halfTween.chain(_easeInTween));\r\n+    _border = _animationController.drive(_borderTween.chain(_easeOutTween));\r\n+    _headerColor =\r\n+        _animationController.drive(_headerColorTween.chain(_easeInTween));\r\n+    _iconColor =\r\n+        _animationController.drive(_iconColorTween.chain(_easeInTween));\r\n+    _backgroundColor =\r\n+        _animationController.drive(_backgroundColorTween.chain(_easeOutTween));\r\n+\r\n+    _isExpanded = PageStorage.maybeOf(context)?.readState(context) as bool? ??\r\n+        widget.initiallyExpanded;\r\n+    if (_isExpanded) {\r\n+      _animationController.value = 1.0;\r\n+    }\r\n+\r\n+    assert(widget.controller?._state == null);\r\n+    _tileController = widget.controller ?? YExpansionTileController();\r\n+    _tileController._state = this;\r\n+  }\r\n+\r\n+  @override\r\n+  void dispose() {\r\n+    _tileController._state = null;\r\n+    _animationController.dispose();\r\n+    super.dispose();\r\n+  }\r\n+\r\n+  void _toggleExpansion() {\r\n+    setState(() {\r\n+      _isExpanded = !_isExpanded;\r\n+      if (_isExpanded) {\r\n+        _animationController.forward();\r\n+      } else {\r\n+        _animationController.reverse().then<void>((void value) {\r\n+          if (!mounted) {\r\n+            return;\r\n+          }\r\n+          setState(() {\r\n+            // Rebuild without widget.children.\r\n+          });\r\n+        });\r\n+      }\r\n+      PageStorage.maybeOf(context)?.writeState(context, _isExpanded);\r\n+    });\r\n+    widget.onExpansionChanged?.call(_isExpanded);\r\n+  }\r\n+\r\n+  void _handleTap() {\r\n+    _toggleExpansion();\r\n+  }\r\n+\r\n+  // Platform or null affinity defaults to trailing.\r\n+  ListTileControlAffinity _effectiveAffinity(\r\n+      ListTileControlAffinity? affinity) {\r\n+    switch (affinity ?? ListTileControlAffinity.trailing) {\r\n+      case ListTileControlAffinity.leading:\r\n+        return ListTileControlAffinity.leading;\r\n+      case ListTileControlAffinity.trailing:\r\n+      case ListTileControlAffinity.platform:\r\n+        return ListTileControlAffinity.trailing;\r\n+    }\r\n+  }\r\n+\r\n+  Widget? _buildIcon(BuildContext context) {\r\n+    return RotationTransition(\r\n+      turns: _iconTurns,\r\n+      child: const Icon(Icons.expand_more),\r\n+    );\r\n+  }\r\n+\r\n+  Widget? _buildLeadingIcon(BuildContext context) {\r\n+    if (_effectiveAffinity(widget.controlAffinity) !=\r\n+        ListTileControlAffinity.leading) {\r\n+      return null;\r\n+    }\r\n+    return _buildIcon(context);\r\n+  }\r\n+\r\n+  Widget? _buildTrailingIcon(BuildContext context) {\r\n+    if (_effectiveAffinity(widget.controlAffinity) !=\r\n+        ListTileControlAffinity.trailing) {\r\n+      return null;\r\n+    }\r\n+    return _buildIcon(context);\r\n+  }\r\n+\r\n+  Widget _buildChildren(BuildContext context, Widget? child) {\r\n+    final YExpansionTileThemeData YexpansionTileTheme =\r\n+        YExpansionTileTheme.of(context);\r\n+    final ShapeBorder YexpansionTileBorder = _border.value ??\r\n+        const Border(\r\n+          top: BorderSide(color: Colors.transparent),\r\n+          bottom: BorderSide(color: Colors.transparent),\r\n+        );\r\n+    final Clip clipBehavior =\r\n+        widget.clipBehavior ?? YexpansionTileTheme.clipBehavior ?? Clip.none;\r\n+\r\n+    return Container(\r\n+      clipBehavior: clipBehavior,\r\n+      decoration: ShapeDecoration(\r\n+        color: _backgroundColor.value ??\r\n+            YexpansionTileTheme.backgroundColor ??\r\n+            Colors.transparent,\r\n+        shape: YexpansionTileBorder,\r\n+      ),\r\n+      child: Column(\r\n+        mainAxisSize: MainAxisSize.min,\r\n+        children: <Widget>[\r\n+          ListTileTheme.merge(\r\n+            iconColor: _iconColor.value ?? YexpansionTileTheme.iconColor,\r\n+            textColor: _headerColor.value,\r\n+            child: ListTile(\r\n+              onTap: _handleTap,\r\n+              contentPadding:\r\n+                  widget.tilePadding ?? YexpansionTileTheme.tilePadding,\r\n+              leading: widget.leading ?? _buildLeadingIcon(context),\r\n+              title: widget.title,\r\n+              subtitle: widget.subtitle,\r\n+              trailing: widget.trailing ?? _buildTrailingIcon(context),\r\n+            ),\r\n+          ),\r\n+          ClipRect(\r\n+            child: Align(\r\n+              alignment: widget.expandedAlignment ??\r\n+                  YexpansionTileTheme.expandedAlignment ??\r\n+                  Alignment.center,\r\n+              heightFactor: _heightFactor.value,\r\n+              child: child,\r\n+            ),\r\n+          ),\r\n+        ],\r\n+      ),\r\n+    );\r\n+  }\r\n+\r\n+  @override\r\n+  void didChangeDependencies() {\r\n+    final ThemeData theme = Theme.of(context);\r\n+    final YExpansionTileThemeData YexpansionTileTheme =\r\n+        YExpansionTileTheme.of(context);\r\n+    final YExpansionTileThemeData defaults = theme.useMaterial3\r\n+        ? _YExpansionTileDefaultsM3(context)\r\n+        : _YExpansionTileDefaultsM2(context);\r\n+    _borderTween\r\n+      ..begin = widget.collapsedShape ??\r\n+          YexpansionTileTheme.collapsedShape ??\r\n+          const Border(\r\n+            top: BorderSide(color: Colors.transparent),\r\n+            bottom: BorderSide(color: Colors.transparent),\r\n+          )\r\n+      ..end = widget.shape ??\r\n+          YexpansionTileTheme.collapsedShape ??\r\n+          Border(\r\n+            top: BorderSide(color: theme.dividerColor),\r\n+            bottom: BorderSide(color: theme.dividerColor),\r\n+          );\r\n+    _headerColorTween\r\n+      ..begin = widget.collapsedTextColor ??\r\n+          YexpansionTileTheme.collapsedTextColor ??\r\n+          defaults.collapsedTextColor\r\n+      ..end = widget.textColor ??\r\n+          YexpansionTileTheme.textColor ??\r\n+          defaults.textColor;\r\n+    _iconColorTween\r\n+      ..begin = widget.collapsedIconColor ??\r\n+          YexpansionTileTheme.collapsedIconColor ??\r\n+          defaults.collapsedIconColor\r\n+      ..end = widget.iconColor ??\r\n+          YexpansionTileTheme.iconColor ??\r\n+          defaults.iconColor;\r\n+    _backgroundColorTween\r\n+      ..begin = widget.collapsedBackgroundColor ??\r\n+          YexpansionTileTheme.collapsedBackgroundColor\r\n+      ..end = widget.backgroundColor ?? YexpansionTileTheme.backgroundColor;\r\n+    super.didChangeDependencies();\r\n+  }\r\n+\r\n+  @override\r\n+  Widget build(BuildContext context) {\r\n+    final YExpansionTileThemeData YexpansionTileTheme =\r\n+        YExpansionTileTheme.of(context);\r\n+    final bool closed = !_isExpanded && _animationController.isDismissed;\r\n+    final bool shouldRemoveChildren = closed && !widget.maintainState;\r\n+\r\n+    final Widget result = Offstage(\r\n+      offstage: closed,\r\n+      child: TickerMode(\r\n+        enabled: !closed,\r\n+        child: Padding(\r\n+          padding: widget.childrenPadding ??\r\n+              YexpansionTileTheme.childrenPadding ??\r\n+              EdgeInsets.zero,\r\n+          child: Column(\r\n+            crossAxisAlignment:\r\n+                widget.expandedCrossAxisAlignment ?? CrossAxisAlignment.center,\r\n+            children: widget.children,\r\n+          ),\r\n+        ),\r\n+      ),\r\n+    );\r\n+\r\n+    return AnimatedBuilder(\r\n+      animation: _animationController.view,\r\n+      builder: _buildChildren,\r\n+      child: shouldRemoveChildren ? null : result,\r\n+    );\r\n+  }\r\n+}\r\n+\r\n+class _YExpansionTileDefaultsM2 extends YExpansionTileThemeData {\r\n+  _YExpansionTileDefaultsM2(this.context);\r\n+\r\n+  final BuildContext context;\r\n+  late final ThemeData _theme = Theme.of(context);\r\n+  late final ColorScheme _colorScheme = _theme.colorScheme;\r\n+\r\n+  @override\r\n+  Color? get textColor => _colorScheme.primary;\r\n+\r\n+  @override\r\n+  Color? get iconColor => _colorScheme.primary;\r\n+\r\n+  @override\r\n+  Color? get collapsedTextColor => _theme.textTheme.titleMedium!.color;\r\n+\r\n+  @override\r\n+  Color? get collapsedIconColor => _theme.unselectedWidgetColor;\r\n+}\r\n+\r\n+// BEGIN GENERATED TOKEN PROPERTIES - YExpansionTile\r\n+\r\n+// Do not edit by hand. The code between the \"BEGIN GENERATED\" and\r\n+// \"END GENERATED\" comments are generated from data in the Material\r\n+// Design token database by the script:\r\n+//   dev/tools/gen_defaults/bin/gen_defaults.dart.\r\n+\r\n+// Token database version: v0_162\r\n+\r\n+class _YExpansionTileDefaultsM3 extends YExpansionTileThemeData {\r\n+  _YExpansionTileDefaultsM3(this.context);\r\n+\r\n+  final BuildContext context;\r\n+  late final ThemeData _theme = Theme.of(context);\r\n+  late final ColorScheme _colors = _theme.colorScheme;\r\n+\r\n+  @override\r\n+  Color? get textColor => _colors.onSurface;\r\n+\r\n+  @override\r\n+  Color? get iconColor => _colors.primary;\r\n+\r\n+  @override\r\n+  Color? get collapsedTextColor => _colors.onSurface;\r\n+\r\n+  @override\r\n+  Color? get collapsedIconColor => _colors.onSurfaceVariant;\r\n+}\r\n+\r\n+// END GENERATED TOKEN PROPERTIES - YExpansionTile\r\n"
                },
                {
                    "date": 1694523145584,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,787 @@\n+// Copyright 2014 The Flutter Authors. All rights reserved.\r\n+// Use of this source code is governed by a BSD-style license that can be\r\n+// found in the LICENSE file.\r\n+\r\n+import 'package:flutter/material.dart';\r\n+import 'package:flutter/widgets.dart';\r\n+\r\n+import 'color_scheme.dart';\r\n+import 'colors.dart';\r\n+import 'expansion_tile_theme.dart';\r\n+import 'icons.dart';\r\n+import 'list_tile.dart';\r\n+import 'list_tile_theme.dart';\r\n+import 'material.dart';\r\n+import 'theme.dart';\r\n+\r\n+const Duration _kExpand = Duration(milliseconds: 200);\r\n+\r\n+/// Enables control over a single [MYExpansionTile]'s expanded/collapsed state.\r\n+///\r\n+/// It can be useful to expand or collapse an [MYExpansionTile]\r\n+/// programatically, for example to reconfigure an existing expansion\r\n+/// tile based on a system event. To do so, create an [MYExpansionTile]\r\n+/// with an [MYExpansionTileController] that's owned by a stateful widget\r\n+/// or look up the tile's automatically created [MYExpansionTileController]\r\n+/// with [MYExpansionTileController.of]\r\n+///\r\n+/// The controller's [expand] and [collapse] methods cause the\r\n+/// the [MYExpansionTile] to rebuild, so they may not be called from\r\n+/// a build method.\r\n+class MYExpansionTileController {\r\n+  /// Create a controller to be used with [MYExpansionTile.controller].\r\n+  MYExpansionTileController();\r\n+\r\n+  _MYExpansionTileState? _state;\r\n+\r\n+  /// Whether the [MYExpansionTile] built with this controller is in expanded state.\r\n+  ///\r\n+  /// This property doesn't take the animation into account. It reports `true`\r\n+  /// even if the expansion animation is not completed.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [expand], which expands the [MYExpansionTile].\r\n+  ///  * [collapse], which collapses the [MYExpansionTile].\r\n+  ///  * [MYExpansionTile.controller] to create an MYExpansionTile with a controller.\r\n+  bool get isExpanded {\r\n+    assert(_state != null);\r\n+    return _state!._isExpanded;\r\n+  }\r\n+\r\n+  /// Expands the [MYExpansionTile] that was built with this controller;\r\n+  ///\r\n+  /// Normally the tile is expanded automatically when the user taps on the header.\r\n+  /// It is sometimes useful to trigger the expansion programmatically due\r\n+  /// to external changes.\r\n+  ///\r\n+  /// If the tile is already in the expanded state (see [isExpanded]), calling\r\n+  /// this method has no effect.\r\n+  ///\r\n+  /// Calling this method may cause the [MYExpansionTile] to rebuild, so it may\r\n+  /// not be called from a build method.\r\n+  ///\r\n+  /// Calling this method will trigger an [MYExpansionTile.onExpansionChanged] callback.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [collapse], which collapses the tile.\r\n+  ///  * [isExpanded] to check whether the tile is expanded.\r\n+  ///  * [MYExpansionTile.controller] to create an MYExpansionTile with a controller.\r\n+  void expand() {\r\n+    assert(_state != null);\r\n+    if (!isExpanded) {\r\n+      _state!._toggleExpansion();\r\n+    }\r\n+  }\r\n+\r\n+  /// Collapses the [MYExpansionTile] that was built with this controller.\r\n+  ///\r\n+  /// Normally the tile is collapsed automatically when the user taps on the header.\r\n+  /// It can be useful sometimes to trigger the collapse programmatically due\r\n+  /// to some external changes.\r\n+  ///\r\n+  /// If the tile is already in the collapsed state (see [isExpanded]), calling\r\n+  /// this method has no effect.\r\n+  ///\r\n+  /// Calling this method may cause the [MYExpansionTile] to rebuild, so it may\r\n+  /// not be called from a build method.\r\n+  ///\r\n+  /// Calling this method will trigger an [MYExpansionTile.onExpansionChanged] callback.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [expand], which expands the tile.\r\n+  ///  * [isExpanded] to check whether the tile is expanded.\r\n+  ///  * [MYExpansionTile.controller] to create an MYExpansionTile with a controller.\r\n+  void collapse() {\r\n+    assert(_state != null);\r\n+    if (isExpanded) {\r\n+      _state!._toggleExpansion();\r\n+    }\r\n+  }\r\n+\r\n+  /// Finds the [MYExpansionTileController] for the closest [MYExpansionTile] instance\r\n+  /// that encloses the given context.\r\n+  ///\r\n+  /// If no [MYExpansionTile] encloses the given context, calling this\r\n+  /// method will cause an assert in debug mode, and throw an\r\n+  /// exception in release mode.\r\n+  ///\r\n+  /// To return null if there is no [MYExpansionTile] use [maybeOf] instead.\r\n+  ///\r\n+  /// {@tool dartpad}\r\n+  /// Typical usage of the [MYExpansionTileController.of] function is to call it from within the\r\n+  /// `build` method of a descendant of an [MYExpansionTile].\r\n+  ///\r\n+  /// When the [MYExpansionTile] is actually created in the same `build`\r\n+  /// function as the callback that refers to the controller, then the\r\n+  /// `context` argument to the `build` function can't be used to find\r\n+  /// the [MYExpansionTileController] (since it's \"above\" the widget\r\n+  /// being returned in the widget tree). In cases like that you can\r\n+  /// add a [Builder] widget, which provides a new scope with a\r\n+  /// [BuildContext] that is \"under\" the [MYExpansionTile]:\r\n+  ///\r\n+  /// ** See code in examples/api/lib/material/expansion_tile/expansion_tile.1.dart **\r\n+  /// {@end-tool}\r\n+  ///\r\n+  /// A more efficient solution is to split your build function into\r\n+  /// several widgets. This introduces a new context from which you\r\n+  /// can obtain the [MYExpansionTileController]. With this approach you\r\n+  /// would have an outer widget that creates the [MYExpansionTile]\r\n+  /// populated by instances of your new inner widgets, and then in\r\n+  /// these inner widgets you would use [MYExpansionTileController.of].\r\n+  static MYExpansionTileController of(BuildContext context) {\r\n+    final _MYExpansionTileState? result =\r\n+        context.findAncestorStateOfType<_MYExpansionTileState>();\r\n+    if (result != null) {\r\n+      return result._tileController;\r\n+    }\r\n+    throw FlutterError.fromParts(<DiagnosticsNode>[\r\n+      ErrorSummary(\r\n+        'MYExpansionTileController.of() called with a context that does not contain a MYExpansionTile.',\r\n+      ),\r\n+      ErrorDescription(\r\n+        'No MYExpansionTile ancestor could be found starting from the context that was passed to MYExpansionTileController.of(). '\r\n+        'This usually happens when the context provided is from the same StatefulWidget as that '\r\n+        'whose build function actually creates the MYExpansionTile widget being sought.',\r\n+      ),\r\n+      ErrorHint(\r\n+        'There are several ways to avoid this problem. The simplest is to use a Builder to get a '\r\n+        'context that is \"under\" the MYExpansionTile. For an example of this, please see the '\r\n+        'documentation for MYExpansionTileController.of():\\n'\r\n+        '  https://api.flutter.dev/flutter/material/MYExpansionTile/of.html',\r\n+      ),\r\n+      ErrorHint(\r\n+        'A more efficient solution is to split your build function into several widgets. This '\r\n+        'introduces a new context from which you can obtain the MYExpansionTile. In this solution, '\r\n+        'you would have an outer widget that creates the MYExpansionTile populated by instances of '\r\n+        'your new inner widgets, and then in these inner widgets you would use MYExpansionTileController.of().\\n'\r\n+        'An other solution is assign a GlobalKey to the MYExpansionTile, '\r\n+        'then use the key.currentState property to obtain the MYExpansionTile rather than '\r\n+        'using the MYExpansionTileController.of() function.',\r\n+      ),\r\n+      context.describeElement('The context used was'),\r\n+    ]);\r\n+  }\r\n+\r\n+  /// Finds the [MYExpansionTile] from the closest instance of this class that\r\n+  /// encloses the given context and returns its [MYExpansionTileController].\r\n+  ///\r\n+  /// If no [MYExpansionTile] encloses the given context then return null.\r\n+  /// To throw an exception instead, use [of] instead of this function.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [of], a similar function to this one that throws if no [MYExpansionTile]\r\n+  ///    encloses the given context. Also includes some sample code in its\r\n+  ///    documentation.\r\n+  static MYExpansionTileController? maybeOf(BuildContext context) {\r\n+    return context\r\n+        .findAncestorStateOfType<_MYExpansionTileState>()\r\n+        ?._tileController;\r\n+  }\r\n+}\r\n+\r\n+/// A single-line [ListTile] with an expansion arrow icon that expands or collapses\r\n+/// the tile to reveal or hide the [children].\r\n+///\r\n+/// This widget is typically used with [ListView] to create an\r\n+/// \"expand / collapse\" list entry. When used with scrolling widgets like\r\n+/// [ListView], a unique [PageStorageKey] must be specified to enable the\r\n+/// [MYExpansionTile] to save and restore its expanded state when it is scrolled\r\n+/// in and out of view.\r\n+///\r\n+/// This class overrides the [ListTileThemeData.iconColor] and [ListTileThemeData.textColor]\r\n+/// theme properties for its [ListTile]. These colors animate between values when\r\n+/// the tile is expanded and collapsed: between [iconColor], [collapsedIconColor] and\r\n+/// between [textColor] and [collapsedTextColor].\r\n+///\r\n+/// The expansion arrow icon is shown on the right by default in left-to-right languages\r\n+/// (i.e. the trailing edge). This can be changed using [controlAffinity]. This maps\r\n+/// to the [leading] and [trailing] properties of [MYExpansionTile].\r\n+///\r\n+/// {@tool dartpad}\r\n+/// This example demonstrates how the [MYExpansionTile] icon's location and appearance\r\n+/// can be customized.\r\n+///\r\n+/// ** See code in examples/api/lib/material/expansion_tile/expansion_tile.0.dart **\r\n+/// {@end-tool}\r\n+///\r\n+/// {@tool dartpad}\r\n+/// This example demonstrates how an [MYExpansionTileController] can be used to\r\n+/// programatically expand or collapse an [MYExpansionTile].\r\n+///\r\n+/// ** See code in examples/api/lib/material/expansion_tile/expansion_tile.1.dart **\r\n+/// {@end-tool}\r\n+///\r\n+/// See also:\r\n+///\r\n+///  * [ListTile], useful for creating expansion tile [children] when the\r\n+///    expansion tile represents a sublist.\r\n+///  * The \"Expand and collapse\" section of\r\n+///    <https://material.io/components/lists#types>\r\n+class MYExpansionTile extends StatefulWidget {\r\n+  /// Creates a single-line [ListTile] with an expansion arrow icon that expands or collapses\r\n+  /// the tile to reveal or hide the [children]. The [initiallyExpanded] property must\r\n+  /// be non-null.\r\n+  const MYExpansionTile({\r\n+    super.key,\r\n+    this.leading,\r\n+    required this.title,\r\n+    this.subtitle,\r\n+    this.onExpansionChanged,\r\n+    this.children = const <Widget>[],\r\n+    this.trailing,\r\n+    this.initiallyExpanded = false,\r\n+    this.maintainState = false,\r\n+    this.tilePadding,\r\n+    this.expandedCrossAxisAlignment,\r\n+    this.expandedAlignment,\r\n+    this.childrenPadding,\r\n+    this.backgroundColor,\r\n+    this.collapsedBackgroundColor,\r\n+    this.textColor,\r\n+    this.collapsedTextColor,\r\n+    this.iconColor,\r\n+    this.collapsedIconColor,\r\n+    this.shape,\r\n+    this.collapsedShape,\r\n+    this.clipBehavior,\r\n+    this.controlAffinity,\r\n+    this.controller,\r\n+  }) : assert(\r\n+          expandedCrossAxisAlignment != CrossAxisAlignment.baseline,\r\n+          'CrossAxisAlignment.baseline is not supported since the expanded children '\r\n+          'are aligned in a column, not a row. Try to use another constant.',\r\n+        );\r\n+\r\n+  /// A widget to display before the title.\r\n+  ///\r\n+  /// Typically a [CircleAvatar] widget.\r\n+  ///\r\n+  /// Depending on the value of [controlAffinity], the [leading] widget\r\n+  /// may replace the rotating expansion arrow icon.\r\n+  final Widget? leading;\r\n+\r\n+  /// The primary content of the list item.\r\n+  ///\r\n+  /// Typically a [Text] widget.\r\n+  final Widget title;\r\n+\r\n+  /// Additional content displayed below the title.\r\n+  ///\r\n+  /// Typically a [Text] widget.\r\n+  final Widget? subtitle;\r\n+\r\n+  /// Called when the tile expands or collapses.\r\n+  ///\r\n+  /// When the tile starts expanding, this function is called with the value\r\n+  /// true. When the tile starts collapsing, this function is called with\r\n+  /// the value false.\r\n+  final ValueChanged<bool>? onExpansionChanged;\r\n+\r\n+  /// The widgets that are displayed when the tile expands.\r\n+  ///\r\n+  /// Typically [ListTile] widgets.\r\n+  final List<Widget> children;\r\n+\r\n+  /// The color to display behind the sublist when expanded.\r\n+  ///\r\n+  /// If this property is null then [MYExpansionTileThemeData.backgroundColor] is used. If that\r\n+  /// is also null then Colors.transparent is used.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n+  ///   [MYExpansionTileThemeData].\r\n+  final Color? backgroundColor;\r\n+\r\n+  /// When not null, defines the background color of tile when the sublist is collapsed.\r\n+  ///\r\n+  /// If this property is null then [MYExpansionTileThemeData.collapsedBackgroundColor] is used.\r\n+  /// If that is also null then Colors.transparent is used.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n+  ///   [MYExpansionTileThemeData].\r\n+  final Color? collapsedBackgroundColor;\r\n+\r\n+  /// A widget to display after the title.\r\n+  ///\r\n+  /// Depending on the value of [controlAffinity], the [trailing] widget\r\n+  /// may replace the rotating expansion arrow icon.\r\n+  final Widget? trailing;\r\n+\r\n+  /// Specifies if the list tile is initially expanded (true) or collapsed (false, the default).\r\n+  final bool initiallyExpanded;\r\n+\r\n+  /// Specifies whether the state of the children is maintained when the tile expands and collapses.\r\n+  ///\r\n+  /// When true, the children are kept in the tree while the tile is collapsed.\r\n+  /// When false (default), the children are removed from the tree when the tile is\r\n+  /// collapsed and recreated upon expansion.\r\n+  final bool maintainState;\r\n+\r\n+  /// Specifies padding for the [ListTile].\r\n+  ///\r\n+  /// Analogous to [ListTile.contentPadding], this property defines the insets for\r\n+  /// the [leading], [title], [subtitle] and [trailing] widgets. It does not inset\r\n+  /// the expanded [children] widgets.\r\n+  ///\r\n+  /// If this property is null then [MYExpansionTileThemeData.tilePadding] is used. If that\r\n+  /// is also null then the tile's padding is `EdgeInsets.symmetric(horizontal: 16.0)`.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n+  ///   [MYExpansionTileThemeData].\r\n+  final EdgeInsetsGeometry? tilePadding;\r\n+\r\n+  /// Specifies the alignment of [children], which are arranged in a column when\r\n+  /// the tile is expanded.\r\n+  ///\r\n+  /// The internals of the expanded tile make use of a [Column] widget for\r\n+  /// [children], and [Align] widget to align the column. The [expandedAlignment]\r\n+  /// parameter is passed directly into the [Align].\r\n+  ///\r\n+  /// Modifying this property controls the alignment of the column within the\r\n+  /// expanded tile, not the alignment of [children] widgets within the column.\r\n+  /// To align each child within [children], see [expandedCrossAxisAlignment].\r\n+  ///\r\n+  /// The width of the column is the width of the widest child widget in [children].\r\n+  ///\r\n+  /// If this property is null then [MYExpansionTileThemeData.expandedAlignment]is used. If that\r\n+  /// is also null then the value of [expandedAlignment] is [Alignment.center].\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n+  ///   [MYExpansionTileThemeData].\r\n+  final Alignment? expandedAlignment;\r\n+\r\n+  /// Specifies the alignment of each child within [children] when the tile is expanded.\r\n+  ///\r\n+  /// The internals of the expanded tile make use of a [Column] widget for\r\n+  /// [children], and the `crossAxisAlignment` parameter is passed directly into\r\n+  /// the [Column].\r\n+  ///\r\n+  /// Modifying this property controls the cross axis alignment of each child\r\n+  /// within its [Column]. The width of the [Column] that houses [children] will\r\n+  /// be the same as the widest child widget in [children]. The width of the\r\n+  /// [Column] might not be equal to the width of the expanded tile.\r\n+  ///\r\n+  /// To align the [Column] along the expanded tile, use the [expandedAlignment]\r\n+  /// property instead.\r\n+  ///\r\n+  /// When the value is null, the value of [expandedCrossAxisAlignment] is\r\n+  /// [CrossAxisAlignment.center].\r\n+  final CrossAxisAlignment? expandedCrossAxisAlignment;\r\n+\r\n+  /// Specifies padding for [children].\r\n+  ///\r\n+  /// If this property is null then [MYExpansionTileThemeData.childrenPadding] is used. If that\r\n+  /// is also null then the value of [childrenPadding] is [EdgeInsets.zero].\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n+  ///   [MYExpansionTileThemeData].\r\n+  final EdgeInsetsGeometry? childrenPadding;\r\n+\r\n+  /// The icon color of tile's expansion arrow icon when the sublist is expanded.\r\n+  ///\r\n+  /// Used to override to the [ListTileThemeData.iconColor].\r\n+  ///\r\n+  /// If this property is null then [MYExpansionTileThemeData.iconColor] is used. If that\r\n+  /// is also null then the value of [ColorScheme.primary] is used.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n+  ///   [MYExpansionTileThemeData].\r\n+  final Color? iconColor;\r\n+\r\n+  /// The icon color of tile's expansion arrow icon when the sublist is collapsed.\r\n+  ///\r\n+  /// Used to override to the [ListTileThemeData.iconColor].\r\n+  ///\r\n+  /// If this property is null then [MYExpansionTileThemeData.collapsedIconColor] is used. If that\r\n+  /// is also null and [ThemeData.useMaterial3] is true, [ColorScheme.onSurface] is used. Otherwise,\r\n+  /// defaults to [ThemeData.unselectedWidgetColor] color.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n+  ///   [MYExpansionTileThemeData].\r\n+  final Color? collapsedIconColor;\r\n+\r\n+  /// The color of the tile's titles when the sublist is expanded.\r\n+  ///\r\n+  /// Used to override to the [ListTileThemeData.textColor].\r\n+  ///\r\n+  /// If this property is null then [MYExpansionTileThemeData.textColor] is used. If that\r\n+  /// is also null then and [ThemeData.useMaterial3] is true, color of the [TextTheme.bodyLarge]\r\n+  /// will be used for the [title] and [subtitle]. Otherwise, defaults to [ColorScheme.primary] color.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n+  ///   [MYExpansionTileThemeData].\r\n+  final Color? textColor;\r\n+\r\n+  /// The color of the tile's titles when the sublist is collapsed.\r\n+  ///\r\n+  /// Used to override to the [ListTileThemeData.textColor].\r\n+  ///\r\n+  /// If this property is null then [MYExpansionTileThemeData.collapsedTextColor] is used.\r\n+  /// If that is also null and [ThemeData.useMaterial3] is true, color of the\r\n+  /// [TextTheme.bodyLarge] will be used for the [title] and [subtitle]. Otherwise,\r\n+  /// defaults to color of the [TextTheme.titleMedium].\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n+  ///   [MYExpansionTileThemeData].\r\n+  final Color? collapsedTextColor;\r\n+\r\n+  /// The tile's border shape when the sublist is expanded.\r\n+  ///\r\n+  /// If this property is null, the [MYExpansionTileThemeData.shape] is used. If that\r\n+  /// is also null, a [Border] with vertical sides default to [ThemeData.dividerColor] is used\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n+  ///   [MYExpansionTileThemeData].\r\n+  final ShapeBorder? shape;\r\n+\r\n+  /// The tile's border shape when the sublist is collapsed.\r\n+  ///\r\n+  /// If this property is null, the [MYExpansionTileThemeData.collapsedShape] is used. If that\r\n+  /// is also null, a [Border] with vertical sides default to Color [Colors.transparent] is used\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n+  ///   [MYExpansionTileThemeData].\r\n+  final ShapeBorder? collapsedShape;\r\n+\r\n+  /// {@macro flutter.material.Material.clipBehavior}\r\n+  ///\r\n+  /// If this property is null, the [MYExpansionTileThemeData.clipBehavior] is used. If that\r\n+  /// is also null, a [Clip.none] is used\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n+  ///   [MYExpansionTileThemeData].\r\n+  final Clip? clipBehavior;\r\n+\r\n+  /// Typically used to force the expansion arrow icon to the tile's leading or trailing edge.\r\n+  ///\r\n+  /// By default, the value of [controlAffinity] is [ListTileControlAffinity.platform],\r\n+  /// which means that the expansion arrow icon will appear on the tile's trailing edge.\r\n+  final ListTileControlAffinity? controlAffinity;\r\n+\r\n+  /// If provided, the controller can be used to expand and collapse tiles.\r\n+  ///\r\n+  /// In cases were control over the tile's state is needed from a callback triggered\r\n+  /// by a widget within the tile, [MYExpansionTileController.of] may be more convenient\r\n+  /// than supplying a controller.\r\n+  final MYExpansionTileController? controller;\r\n+\r\n+  @override\r\n+  State<MYExpansionTile> createState() => _MYExpansionTileState();\r\n+}\r\n+\r\n+class _MYExpansionTileState extends State<MYExpansionTile>\r\n+    with SingleTickerProviderStateMixin {\r\n+  static final Animatable<double> _easeOutTween =\r\n+      CurveTween(curve: Curves.easeOut);\r\n+  static final Animatable<double> _easeInTween =\r\n+      CurveTween(curve: Curves.easeIn);\r\n+  static final Animatable<double> _halfTween =\r\n+      Tween<double>(begin: 0.0, end: 0.5);\r\n+\r\n+  final ShapeBorderTween _borderTween = ShapeBorderTween();\r\n+  final ColorTween _headerColorTween = ColorTween();\r\n+  final ColorTween _iconColorTween = ColorTween();\r\n+  final ColorTween _backgroundColorTween = ColorTween();\r\n+\r\n+  late AnimationController _animationController;\r\n+  late Animation<double> _iconTurns;\r\n+  late Animation<double> _heightFactor;\r\n+  late Animation<ShapeBorder?> _border;\r\n+  late Animation<Color?> _headerColor;\r\n+  late Animation<Color?> _iconColor;\r\n+  late Animation<Color?> _backgroundColor;\r\n+\r\n+  bool _isExpanded = false;\r\n+  late MYExpansionTileController _tileController;\r\n+\r\n+  @override\r\n+  void initState() {\r\n+    super.initState();\r\n+    _animationController = AnimationController(duration: _kExpand, vsync: this);\r\n+    _heightFactor = _animationController.drive(_easeInTween);\r\n+    _iconTurns = _animationController.drive(_halfTween.chain(_easeInTween));\r\n+    _border = _animationController.drive(_borderTween.chain(_easeOutTween));\r\n+    _headerColor =\r\n+        _animationController.drive(_headerColorTween.chain(_easeInTween));\r\n+    _iconColor =\r\n+        _animationController.drive(_iconColorTween.chain(_easeInTween));\r\n+    _backgroundColor =\r\n+        _animationController.drive(_backgroundColorTween.chain(_easeOutTween));\r\n+\r\n+    _isExpanded = PageStorage.maybeOf(context)?.readState(context) as bool? ??\r\n+        widget.initiallyExpanded;\r\n+    if (_isExpanded) {\r\n+      _animationController.value = 1.0;\r\n+    }\r\n+\r\n+    assert(widget.controller?._state == null);\r\n+    _tileController = widget.controller ?? MYExpansionTileController();\r\n+    _tileController._state = this;\r\n+  }\r\n+\r\n+  @override\r\n+  void dispose() {\r\n+    _tileController._state = null;\r\n+    _animationController.dispose();\r\n+    super.dispose();\r\n+  }\r\n+\r\n+  void _toggleExpansion() {\r\n+    setState(() {\r\n+      _isExpanded = !_isExpanded;\r\n+      if (_isExpanded) {\r\n+        _animationController.forward();\r\n+      } else {\r\n+        _animationController.reverse().then<void>((void value) {\r\n+          if (!mounted) {\r\n+            return;\r\n+          }\r\n+          setState(() {\r\n+            // Rebuild without widget.children.\r\n+          });\r\n+        });\r\n+      }\r\n+      PageStorage.maybeOf(context)?.writeState(context, _isExpanded);\r\n+    });\r\n+    widget.onExpansionChanged?.call(_isExpanded);\r\n+  }\r\n+\r\n+  void _handleTap() {\r\n+    _toggleExpansion();\r\n+  }\r\n+\r\n+  // Platform or null affinity defaults to trailing.\r\n+  ListTileControlAffinity _effectiveAffinity(\r\n+      ListTileControlAffinity? affinity) {\r\n+    switch (affinity ?? ListTileControlAffinity.trailing) {\r\n+      case ListTileControlAffinity.leading:\r\n+        return ListTileControlAffinity.leading;\r\n+      case ListTileControlAffinity.trailing:\r\n+      case ListTileControlAffinity.platform:\r\n+        return ListTileControlAffinity.trailing;\r\n+    }\r\n+  }\r\n+\r\n+  Widget? _buildIcon(BuildContext context) {\r\n+    return RotationTransition(\r\n+      turns: _iconTurns,\r\n+      child: const Icon(Icons.expand_more),\r\n+    );\r\n+  }\r\n+\r\n+  Widget? _buildLeadingIcon(BuildContext context) {\r\n+    if (_effectiveAffinity(widget.controlAffinity) !=\r\n+        ListTileControlAffinity.leading) {\r\n+      return null;\r\n+    }\r\n+    return _buildIcon(context);\r\n+  }\r\n+\r\n+  Widget? _buildTrailingIcon(BuildContext context) {\r\n+    if (_effectiveAffinity(widget.controlAffinity) !=\r\n+        ListTileControlAffinity.trailing) {\r\n+      return null;\r\n+    }\r\n+    return _buildIcon(context);\r\n+  }\r\n+\r\n+  Widget _buildChildren(BuildContext context, Widget? child) {\r\n+    final MYExpansionTileThemeData MYexpansionTileTheme =\r\n+        MYExpansionTileTheme.of(context);\r\n+    final ShapeBorder MYexpansionTileBorder = _border.value ??\r\n+        const Border(\r\n+          top: BorderSide(color: Colors.transparent),\r\n+          bottom: BorderSide(color: Colors.transparent),\r\n+        );\r\n+    final Clip clipBehavior =\r\n+        widget.clipBehavior ?? MYexpansionTileTheme.clipBehavior ?? Clip.none;\r\n+\r\n+    return Container(\r\n+      clipBehavior: clipBehavior,\r\n+      decoration: ShapeDecoration(\r\n+        color: _backgroundColor.value ??\r\n+            MYexpansionTileTheme.backgroundColor ??\r\n+            Colors.transparent,\r\n+        shape: MYexpansionTileBorder,\r\n+      ),\r\n+      child: Column(\r\n+        mainAxisSize: MainAxisSize.min,\r\n+        children: <Widget>[\r\n+          ListTileTheme.merge(\r\n+            iconColor: _iconColor.value ?? MYexpansionTileTheme.iconColor,\r\n+            textColor: _headerColor.value,\r\n+            child: ListTile(\r\n+              onTap: _handleTap,\r\n+              contentPadding:\r\n+                  widget.tilePadding ?? MYexpansionTileTheme.tilePadding,\r\n+              leading: widget.leading ?? _buildLeadingIcon(context),\r\n+              title: widget.title,\r\n+              subtitle: widget.subtitle,\r\n+              trailing: widget.trailing ?? _buildTrailingIcon(context),\r\n+            ),\r\n+          ),\r\n+          ClipRect(\r\n+            child: Align(\r\n+              alignment: widget.expandedAlignment ??\r\n+                  MYexpansionTileTheme.expandedAlignment ??\r\n+                  Alignment.center,\r\n+              heightFactor: _heightFactor.value,\r\n+              child: child,\r\n+            ),\r\n+          ),\r\n+        ],\r\n+      ),\r\n+    );\r\n+  }\r\n+\r\n+  @override\r\n+  void didChangeDependencies() {\r\n+    final ThemeData theme = Theme.of(context);\r\n+    final MYExpansionTileThemeData MYexpansionTileTheme =\r\n+        MYExpansionTileTheme.of(context);\r\n+    final MYExpansionTileThemeData defaults = theme.useMaterial3\r\n+        ? _MYExpansionTileDefaultsM3(context)\r\n+        : _MYExpansionTileDefaultsM2(context);\r\n+    _borderTween\r\n+      ..begin = widget.collapsedShape ??\r\n+          MYexpansionTileTheme.collapsedShape ??\r\n+          const Border(\r\n+            top: BorderSide(color: Colors.transparent),\r\n+            bottom: BorderSide(color: Colors.transparent),\r\n+          )\r\n+      ..end = widget.shape ??\r\n+          MYexpansionTileTheme.collapsedShape ??\r\n+          Border(\r\n+            top: BorderSide(color: theme.dividerColor),\r\n+            bottom: BorderSide(color: theme.dividerColor),\r\n+          );\r\n+    _headerColorTween\r\n+      ..begin = widget.collapsedTextColor ??\r\n+          MYexpansionTileTheme.collapsedTextColor ??\r\n+          defaults.collapsedTextColor\r\n+      ..end = widget.textColor ??\r\n+          MYexpansionTileTheme.textColor ??\r\n+          defaults.textColor;\r\n+    _iconColorTween\r\n+      ..begin = widget.collapsedIconColor ??\r\n+          MYexpansionTileTheme.collapsedIconColor ??\r\n+          defaults.collapsedIconColor\r\n+      ..end = widget.iconColor ??\r\n+          MYexpansionTileTheme.iconColor ??\r\n+          defaults.iconColor;\r\n+    _backgroundColorTween\r\n+      ..begin = widget.collapsedBackgroundColor ??\r\n+          MYexpansionTileTheme.collapsedBackgroundColor\r\n+      ..end = widget.backgroundColor ?? MYexpansionTileTheme.backgroundColor;\r\n+    super.didChangeDependencies();\r\n+  }\r\n+\r\n+  @override\r\n+  Widget build(BuildContext context) {\r\n+    final MYExpansionTileThemeData MYexpansionTileTheme =\r\n+        MYExpansionTileTheme.of(context);\r\n+    final bool closed = !_isExpanded && _animationController.isDismissed;\r\n+    final bool shouldRemoveChildren = closed && !widget.maintainState;\r\n+\r\n+    final Widget result = Offstage(\r\n+      offstage: closed,\r\n+      child: TickerMode(\r\n+        enabled: !closed,\r\n+        child: Padding(\r\n+          padding: widget.childrenPadding ??\r\n+              MYexpansionTileTheme.childrenPadding ??\r\n+              EdgeInsets.zero,\r\n+          child: Column(\r\n+            crossAxisAlignment:\r\n+                widget.expandedCrossAxisAlignment ?? CrossAxisAlignment.center,\r\n+            children: widget.children,\r\n+          ),\r\n+        ),\r\n+      ),\r\n+    );\r\n+\r\n+    return AnimatedBuilder(\r\n+      animation: _animationController.view,\r\n+      builder: _buildChildren,\r\n+      child: shouldRemoveChildren ? null : result,\r\n+    );\r\n+  }\r\n+}\r\n+\r\n+class _MYExpansionTileDefaultsM2 extends MYExpansionTileThemeData {\r\n+  _MYExpansionTileDefaultsM2(this.context);\r\n+\r\n+  final BuildContext context;\r\n+  late final ThemeData _theme = Theme.of(context);\r\n+  late final ColorScheme _colorScheme = _theme.colorScheme;\r\n+\r\n+  @override\r\n+  Color? get textColor => _colorScheme.primary;\r\n+\r\n+  @override\r\n+  Color? get iconColor => _colorScheme.primary;\r\n+\r\n+  @override\r\n+  Color? get collapsedTextColor => _theme.textTheme.titleMedium!.color;\r\n+\r\n+  @override\r\n+  Color? get collapsedIconColor => _theme.unselectedWidgetColor;\r\n+}\r\n+\r\n+// BEGIN GENERATED TOKEN PROPERTIES - MYExpansionTile\r\n+\r\n+// Do not edit by hand. The code between the \"BEGIN GENERATED\" and\r\n+// \"END GENERATED\" comments are generated from data in the Material\r\n+// Design token database by the script:\r\n+//   dev/tools/gen_defaults/bin/gen_defaults.dart.\r\n+\r\n+// Token database version: v0_162\r\n+\r\n+class _MYExpansionTileDefaultsM3 extends MYExpansionTileThemeData {\r\n+  _MYExpansionTileDefaultsM3(this.context);\r\n+\r\n+  final BuildContext context;\r\n+  late final ThemeData _theme = Theme.of(context);\r\n+  late final ColorScheme _colors = _theme.colorScheme;\r\n+\r\n+  @override\r\n+  Color? get textColor => _colors.onSurface;\r\n+\r\n+  @override\r\n+  Color? get iconColor => _colors.primary;\r\n+\r\n+  @override\r\n+  Color? get collapsedTextColor => _colors.onSurface;\r\n+\r\n+  @override\r\n+  Color? get collapsedIconColor => _colors.onSurfaceVariant;\r\n+}\r\n+\r\n+// END GENERATED TOKEN PROPERTIES - MYExpansionTile\r\n"
                },
                {
                    "date": 1694523179233,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -612,9 +612,9 @@\n     return _buildIcon(context);\r\n   }\r\n \r\n   Widget _buildChildren(BuildContext context, Widget? child) {\r\n-    final MYExpansionTileThemeData MYexpansionTileTheme =\r\n+    final ExpansionTileThemeData MYexpansionTileTheme =\r\n         MYExpansionTileTheme.of(context);\r\n     final ShapeBorder MYexpansionTileBorder = _border.value ??\r\n         const Border(\r\n           top: BorderSide(color: Colors.transparent),\r\n@@ -784,1576 +784,4 @@\n   Color? get collapsedIconColor => _colors.onSurfaceVariant;\r\n }\r\n \r\n // END GENERATED TOKEN PROPERTIES - MYExpansionTile\r\n-// Copyright 2014 The Flutter Authors. All rights reserved.\r\n-// Use of this source code is governed by a BSD-style license that can be\r\n-// found in the LICENSE file.\r\n-\r\n-import 'package:flutter/widgets.dart';\r\n-\r\n-import 'color_scheme.dart';\r\n-import 'colors.dart';\r\n-import 'expansion_tile_theme.dart';\r\n-import 'icons.dart';\r\n-import 'list_tile.dart';\r\n-import 'list_tile_theme.dart';\r\n-import 'material.dart';\r\n-import 'theme.dart';\r\n-\r\n-const Duration _kExpand = Duration(milliseconds: 200);\r\n-\r\n-/// Enables control over a single [YExpansionTile]'s expanded/collapsed state.\r\n-///\r\n-/// It can be useful to expand or collapse an [YExpansionTile]\r\n-/// programatically, for example to reconfigure an existing expansion\r\n-/// tile based on a system event. To do so, create an [YExpansionTile]\r\n-/// with an [YExpansionTileController] that's owned by a stateful widget\r\n-/// or look up the tile's automatically created [YExpansionTileController]\r\n-/// with [YExpansionTileController.of]\r\n-///\r\n-/// The controller's [expand] and [collapse] methods cause the\r\n-/// the [YExpansionTile] to rebuild, so they may not be called from\r\n-/// a build method.\r\n-class YExpansionTileController {\r\n-  /// Create a controller to be used with [YExpansionTile.controller].\r\n-  YExpansionTileController();\r\n-\r\n-  _YExpansionTileState? _state;\r\n-\r\n-  /// Whether the [YExpansionTile] built with this controller is in expanded state.\r\n-  ///\r\n-  /// This property doesn't take the animation into account. It reports `true`\r\n-  /// even if the expansion animation is not completed.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  ///  * [expand], which expands the [YExpansionTile].\r\n-  ///  * [collapse], which collapses the [YExpansionTile].\r\n-  ///  * [YExpansionTile.controller] to create an YExpansionTile with a controller.\r\n-  bool get isExpanded {\r\n-    assert(_state != null);\r\n-    return _state!._isExpanded;\r\n-  }\r\n-\r\n-  /// Expands the [YExpansionTile] that was built with this controller;\r\n-  ///\r\n-  /// Normally the tile is expanded automatically when the user taps on the header.\r\n-  /// It is sometimes useful to trigger the expansion programmatically due\r\n-  /// to external changes.\r\n-  ///\r\n-  /// If the tile is already in the expanded state (see [isExpanded]), calling\r\n-  /// this method has no effect.\r\n-  ///\r\n-  /// Calling this method may cause the [YExpansionTile] to rebuild, so it may\r\n-  /// not be called from a build method.\r\n-  ///\r\n-  /// Calling this method will trigger an [YExpansionTile.onExpansionChanged] callback.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  ///  * [collapse], which collapses the tile.\r\n-  ///  * [isExpanded] to check whether the tile is expanded.\r\n-  ///  * [YExpansionTile.controller] to create an YExpansionTile with a controller.\r\n-  void expand() {\r\n-    assert(_state != null);\r\n-    if (!isExpanded) {\r\n-      _state!._toggleExpansion();\r\n-    }\r\n-  }\r\n-\r\n-  /// Collapses the [YExpansionTile] that was built with this controller.\r\n-  ///\r\n-  /// Normally the tile is collapsed automatically when the user taps on the header.\r\n-  /// It can be useful sometimes to trigger the collapse programmatically due\r\n-  /// to some external changes.\r\n-  ///\r\n-  /// If the tile is already in the collapsed state (see [isExpanded]), calling\r\n-  /// this method has no effect.\r\n-  ///\r\n-  /// Calling this method may cause the [YExpansionTile] to rebuild, so it may\r\n-  /// not be called from a build method.\r\n-  ///\r\n-  /// Calling this method will trigger an [YExpansionTile.onExpansionChanged] callback.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  ///  * [expand], which expands the tile.\r\n-  ///  * [isExpanded] to check whether the tile is expanded.\r\n-  ///  * [YExpansionTile.controller] to create an YExpansionTile with a controller.\r\n-  void collapse() {\r\n-    assert(_state != null);\r\n-    if (isExpanded) {\r\n-      _state!._toggleExpansion();\r\n-    }\r\n-  }\r\n-\r\n-  /// Finds the [YExpansionTileController] for the closest [YExpansionTile] instance\r\n-  /// that encloses the given context.\r\n-  ///\r\n-  /// If no [YExpansionTile] encloses the given context, calling this\r\n-  /// method will cause an assert in debug mode, and throw an\r\n-  /// exception in release mode.\r\n-  ///\r\n-  /// To return null if there is no [YExpansionTile] use [maybeOf] instead.\r\n-  ///\r\n-  /// {@tool dartpad}\r\n-  /// Typical usage of the [YExpansionTileController.of] function is to call it from within the\r\n-  /// `build` method of a descendant of an [YExpansionTile].\r\n-  ///\r\n-  /// When the [YExpansionTile] is actually created in the same `build`\r\n-  /// function as the callback that refers to the controller, then the\r\n-  /// `context` argument to the `build` function can't be used to find\r\n-  /// the [YExpansionTileController] (since it's \"above\" the widget\r\n-  /// being returned in the widget tree). In cases like that you can\r\n-  /// add a [Builder] widget, which provides a new scope with a\r\n-  /// [BuildContext] that is \"under\" the [YExpansionTile]:\r\n-  ///\r\n-  /// ** See code in examples/api/lib/material/expansion_tile/expansion_tile.1.dart **\r\n-  /// {@end-tool}\r\n-  ///\r\n-  /// A more efficient solution is to split your build function into\r\n-  /// several widgets. This introduces a new context from which you\r\n-  /// can obtain the [YExpansionTileController]. With this approach you\r\n-  /// would have an outer widget that creates the [YExpansionTile]\r\n-  /// populated by instances of your new inner widgets, and then in\r\n-  /// these inner widgets you would use [YExpansionTileController.of].\r\n-  static YExpansionTileController of(BuildContext context) {\r\n-    final _YExpansionTileState? result =\r\n-        context.findAncestorStateOfType<_YExpansionTileState>();\r\n-    if (result != null) {\r\n-      return result._tileController;\r\n-    }\r\n-    throw FlutterError.fromParts(<DiagnosticsNode>[\r\n-      ErrorSummary(\r\n-        'YExpansionTileController.of() called with a context that does not contain a YExpansionTile.',\r\n-      ),\r\n-      ErrorDescription(\r\n-        'No YExpansionTile ancestor could be found starting from the context that was passed to YExpansionTileController.of(). '\r\n-        'This usually happens when the context provided is from the same StatefulWidget as that '\r\n-        'whose build function actually creates the YExpansionTile widget being sought.',\r\n-      ),\r\n-      ErrorHint(\r\n-        'There are several ways to avoid this problem. The simplest is to use a Builder to get a '\r\n-        'context that is \"under\" the YExpansionTile. For an example of this, please see the '\r\n-        'documentation for YExpansionTileController.of():\\n'\r\n-        '  https://api.flutter.dev/flutter/material/YExpansionTile/of.html',\r\n-      ),\r\n-      ErrorHint(\r\n-        'A more efficient solution is to split your build function into several widgets. This '\r\n-        'introduces a new context from which you can obtain the YExpansionTile. In this solution, '\r\n-        'you would have an outer widget that creates the YExpansionTile populated by instances of '\r\n-        'your new inner widgets, and then in these inner widgets you would use YExpansionTileController.of().\\n'\r\n-        'An other solution is assign a GlobalKey to the YExpansionTile, '\r\n-        'then use the key.currentState property to obtain the YExpansionTile rather than '\r\n-        'using the YExpansionTileController.of() function.',\r\n-      ),\r\n-      context.describeElement('The context used was'),\r\n-    ]);\r\n-  }\r\n-\r\n-  /// Finds the [YExpansionTile] from the closest instance of this class that\r\n-  /// encloses the given context and returns its [YExpansionTileController].\r\n-  ///\r\n-  /// If no [YExpansionTile] encloses the given context then return null.\r\n-  /// To throw an exception instead, use [of] instead of this function.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  ///  * [of], a similar function to this one that throws if no [YExpansionTile]\r\n-  ///    encloses the given context. Also includes some sample code in its\r\n-  ///    documentation.\r\n-  static YExpansionTileController? maybeOf(BuildContext context) {\r\n-    return context\r\n-        .findAncestorStateOfType<_YExpansionTileState>()\r\n-        ?._tileController;\r\n-  }\r\n-}\r\n-\r\n-/// A single-line [ListTile] with an expansion arrow icon that expands or collapses\r\n-/// the tile to reveal or hide the [children].\r\n-///\r\n-/// This widget is typically used with [ListView] to create an\r\n-/// \"expand / collapse\" list entry. When used with scrolling widgets like\r\n-/// [ListView], a unique [PageStorageKey] must be specified to enable the\r\n-/// [YExpansionTile] to save and restore its expanded state when it is scrolled\r\n-/// in and out of view.\r\n-///\r\n-/// This class overrides the [ListTileThemeData.iconColor] and [ListTileThemeData.textColor]\r\n-/// theme properties for its [ListTile]. These colors animate between values when\r\n-/// the tile is expanded and collapsed: between [iconColor], [collapsedIconColor] and\r\n-/// between [textColor] and [collapsedTextColor].\r\n-///\r\n-/// The expansion arrow icon is shown on the right by default in left-to-right languages\r\n-/// (i.e. the trailing edge). This can be changed using [controlAffinity]. This maps\r\n-/// to the [leading] and [trailing] properties of [YExpansionTile].\r\n-///\r\n-/// {@tool dartpad}\r\n-/// This example demonstrates how the [YExpansionTile] icon's location and appearance\r\n-/// can be customized.\r\n-///\r\n-/// ** See code in examples/api/lib/material/expansion_tile/expansion_tile.0.dart **\r\n-/// {@end-tool}\r\n-///\r\n-/// {@tool dartpad}\r\n-/// This example demonstrates how an [YExpansionTileController] can be used to\r\n-/// programatically expand or collapse an [YExpansionTile].\r\n-///\r\n-/// ** See code in examples/api/lib/material/expansion_tile/expansion_tile.1.dart **\r\n-/// {@end-tool}\r\n-///\r\n-/// See also:\r\n-///\r\n-///  * [ListTile], useful for creating expansion tile [children] when the\r\n-///    expansion tile represents a sublist.\r\n-///  * The \"Expand and collapse\" section of\r\n-///    <https://material.io/components/lists#types>\r\n-class YExpansionTile extends StatefulWidget {\r\n-  /// Creates a single-line [ListTile] with an expansion arrow icon that expands or collapses\r\n-  /// the tile to reveal or hide the [children]. The [initiallyExpanded] property must\r\n-  /// be non-null.\r\n-  const YExpansionTile({\r\n-    super.key,\r\n-    this.leading,\r\n-    required this.title,\r\n-    this.subtitle,\r\n-    this.onExpansionChanged,\r\n-    this.children = const <Widget>[],\r\n-    this.trailing,\r\n-    this.initiallyExpanded = false,\r\n-    this.maintainState = false,\r\n-    this.tilePadding,\r\n-    this.expandedCrossAxisAlignment,\r\n-    this.expandedAlignment,\r\n-    this.childrenPadding,\r\n-    this.backgroundColor,\r\n-    this.collapsedBackgroundColor,\r\n-    this.textColor,\r\n-    this.collapsedTextColor,\r\n-    this.iconColor,\r\n-    this.collapsedIconColor,\r\n-    this.shape,\r\n-    this.collapsedShape,\r\n-    this.clipBehavior,\r\n-    this.controlAffinity,\r\n-    this.controller,\r\n-  }) : assert(\r\n-          expandedCrossAxisAlignment != CrossAxisAlignment.baseline,\r\n-          'CrossAxisAlignment.baseline is not supported since the expanded children '\r\n-          'are aligned in a column, not a row. Try to use another constant.',\r\n-        );\r\n-\r\n-  /// A widget to display before the title.\r\n-  ///\r\n-  /// Typically a [CircleAvatar] widget.\r\n-  ///\r\n-  /// Depending on the value of [controlAffinity], the [leading] widget\r\n-  /// may replace the rotating expansion arrow icon.\r\n-  final Widget? leading;\r\n-\r\n-  /// The primary content of the list item.\r\n-  ///\r\n-  /// Typically a [Text] widget.\r\n-  final Widget title;\r\n-\r\n-  /// Additional content displayed below the title.\r\n-  ///\r\n-  /// Typically a [Text] widget.\r\n-  final Widget? subtitle;\r\n-\r\n-  /// Called when the tile expands or collapses.\r\n-  ///\r\n-  /// When the tile starts expanding, this function is called with the value\r\n-  /// true. When the tile starts collapsing, this function is called with\r\n-  /// the value false.\r\n-  final ValueChanged<bool>? onExpansionChanged;\r\n-\r\n-  /// The widgets that are displayed when the tile expands.\r\n-  ///\r\n-  /// Typically [ListTile] widgets.\r\n-  final List<Widget> children;\r\n-\r\n-  /// The color to display behind the sublist when expanded.\r\n-  ///\r\n-  /// If this property is null then [YExpansionTileThemeData.backgroundColor] is used. If that\r\n-  /// is also null then Colors.transparent is used.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [YExpansionTileTheme.of], which returns the nearest [YExpansionTileTheme]'s\r\n-  ///   [YExpansionTileThemeData].\r\n-  final Color? backgroundColor;\r\n-\r\n-  /// When not null, defines the background color of tile when the sublist is collapsed.\r\n-  ///\r\n-  /// If this property is null then [YExpansionTileThemeData.collapsedBackgroundColor] is used.\r\n-  /// If that is also null then Colors.transparent is used.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [YExpansionTileTheme.of], which returns the nearest [YExpansionTileTheme]'s\r\n-  ///   [YExpansionTileThemeData].\r\n-  final Color? collapsedBackgroundColor;\r\n-\r\n-  /// A widget to display after the title.\r\n-  ///\r\n-  /// Depending on the value of [controlAffinity], the [trailing] widget\r\n-  /// may replace the rotating expansion arrow icon.\r\n-  final Widget? trailing;\r\n-\r\n-  /// Specifies if the list tile is initially expanded (true) or collapsed (false, the default).\r\n-  final bool initiallyExpanded;\r\n-\r\n-  /// Specifies whether the state of the children is maintained when the tile expands and collapses.\r\n-  ///\r\n-  /// When true, the children are kept in the tree while the tile is collapsed.\r\n-  /// When false (default), the children are removed from the tree when the tile is\r\n-  /// collapsed and recreated upon expansion.\r\n-  final bool maintainState;\r\n-\r\n-  /// Specifies padding for the [ListTile].\r\n-  ///\r\n-  /// Analogous to [ListTile.contentPadding], this property defines the insets for\r\n-  /// the [leading], [title], [subtitle] and [trailing] widgets. It does not inset\r\n-  /// the expanded [children] widgets.\r\n-  ///\r\n-  /// If this property is null then [YExpansionTileThemeData.tilePadding] is used. If that\r\n-  /// is also null then the tile's padding is `EdgeInsets.symmetric(horizontal: 16.0)`.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [YExpansionTileTheme.of], which returns the nearest [YExpansionTileTheme]'s\r\n-  ///   [YExpansionTileThemeData].\r\n-  final EdgeInsetsGeometry? tilePadding;\r\n-\r\n-  /// Specifies the alignment of [children], which are arranged in a column when\r\n-  /// the tile is expanded.\r\n-  ///\r\n-  /// The internals of the expanded tile make use of a [Column] widget for\r\n-  /// [children], and [Align] widget to align the column. The [expandedAlignment]\r\n-  /// parameter is passed directly into the [Align].\r\n-  ///\r\n-  /// Modifying this property controls the alignment of the column within the\r\n-  /// expanded tile, not the alignment of [children] widgets within the column.\r\n-  /// To align each child within [children], see [expandedCrossAxisAlignment].\r\n-  ///\r\n-  /// The width of the column is the width of the widest child widget in [children].\r\n-  ///\r\n-  /// If this property is null then [YExpansionTileThemeData.expandedAlignment]is used. If that\r\n-  /// is also null then the value of [expandedAlignment] is [Alignment.center].\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [YExpansionTileTheme.of], which returns the nearest [YExpansionTileTheme]'s\r\n-  ///   [YExpansionTileThemeData].\r\n-  final Alignment? expandedAlignment;\r\n-\r\n-  /// Specifies the alignment of each child within [children] when the tile is expanded.\r\n-  ///\r\n-  /// The internals of the expanded tile make use of a [Column] widget for\r\n-  /// [children], and the `crossAxisAlignment` parameter is passed directly into\r\n-  /// the [Column].\r\n-  ///\r\n-  /// Modifying this property controls the cross axis alignment of each child\r\n-  /// within its [Column]. The width of the [Column] that houses [children] will\r\n-  /// be the same as the widest child widget in [children]. The width of the\r\n-  /// [Column] might not be equal to the width of the expanded tile.\r\n-  ///\r\n-  /// To align the [Column] along the expanded tile, use the [expandedAlignment]\r\n-  /// property instead.\r\n-  ///\r\n-  /// When the value is null, the value of [expandedCrossAxisAlignment] is\r\n-  /// [CrossAxisAlignment.center].\r\n-  final CrossAxisAlignment? expandedCrossAxisAlignment;\r\n-\r\n-  /// Specifies padding for [children].\r\n-  ///\r\n-  /// If this property is null then [YExpansionTileThemeData.childrenPadding] is used. If that\r\n-  /// is also null then the value of [childrenPadding] is [EdgeInsets.zero].\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [YExpansionTileTheme.of], which returns the nearest [YExpansionTileTheme]'s\r\n-  ///   [YExpansionTileThemeData].\r\n-  final EdgeInsetsGeometry? childrenPadding;\r\n-\r\n-  /// The icon color of tile's expansion arrow icon when the sublist is expanded.\r\n-  ///\r\n-  /// Used to override to the [ListTileThemeData.iconColor].\r\n-  ///\r\n-  /// If this property is null then [YExpansionTileThemeData.iconColor] is used. If that\r\n-  /// is also null then the value of [ColorScheme.primary] is used.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [YExpansionTileTheme.of], which returns the nearest [YExpansionTileTheme]'s\r\n-  ///   [YExpansionTileThemeData].\r\n-  final Color? iconColor;\r\n-\r\n-  /// The icon color of tile's expansion arrow icon when the sublist is collapsed.\r\n-  ///\r\n-  /// Used to override to the [ListTileThemeData.iconColor].\r\n-  ///\r\n-  /// If this property is null then [YExpansionTileThemeData.collapsedIconColor] is used. If that\r\n-  /// is also null and [ThemeData.useMaterial3] is true, [ColorScheme.onSurface] is used. Otherwise,\r\n-  /// defaults to [ThemeData.unselectedWidgetColor] color.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [YExpansionTileTheme.of], which returns the nearest [YExpansionTileTheme]'s\r\n-  ///   [YExpansionTileThemeData].\r\n-  final Color? collapsedIconColor;\r\n-\r\n-  /// The color of the tile's titles when the sublist is expanded.\r\n-  ///\r\n-  /// Used to override to the [ListTileThemeData.textColor].\r\n-  ///\r\n-  /// If this property is null then [YExpansionTileThemeData.textColor] is used. If that\r\n-  /// is also null then and [ThemeData.useMaterial3] is true, color of the [TextTheme.bodyLarge]\r\n-  /// will be used for the [title] and [subtitle]. Otherwise, defaults to [ColorScheme.primary] color.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [YExpansionTileTheme.of], which returns the nearest [YExpansionTileTheme]'s\r\n-  ///   [YExpansionTileThemeData].\r\n-  final Color? textColor;\r\n-\r\n-  /// The color of the tile's titles when the sublist is collapsed.\r\n-  ///\r\n-  /// Used to override to the [ListTileThemeData.textColor].\r\n-  ///\r\n-  /// If this property is null then [YExpansionTileThemeData.collapsedTextColor] is used.\r\n-  /// If that is also null and [ThemeData.useMaterial3] is true, color of the\r\n-  /// [TextTheme.bodyLarge] will be used for the [title] and [subtitle]. Otherwise,\r\n-  /// defaults to color of the [TextTheme.titleMedium].\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [YExpansionTileTheme.of], which returns the nearest [YExpansionTileTheme]'s\r\n-  ///   [YExpansionTileThemeData].\r\n-  final Color? collapsedTextColor;\r\n-\r\n-  /// The tile's border shape when the sublist is expanded.\r\n-  ///\r\n-  /// If this property is null, the [YExpansionTileThemeData.shape] is used. If that\r\n-  /// is also null, a [Border] with vertical sides default to [ThemeData.dividerColor] is used\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [YExpansionTileTheme.of], which returns the nearest [YExpansionTileTheme]'s\r\n-  ///   [YExpansionTileThemeData].\r\n-  final ShapeBorder? shape;\r\n-\r\n-  /// The tile's border shape when the sublist is collapsed.\r\n-  ///\r\n-  /// If this property is null, the [YExpansionTileThemeData.collapsedShape] is used. If that\r\n-  /// is also null, a [Border] with vertical sides default to Color [Colors.transparent] is used\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [YExpansionTileTheme.of], which returns the nearest [YExpansionTileTheme]'s\r\n-  ///   [YExpansionTileThemeData].\r\n-  final ShapeBorder? collapsedShape;\r\n-\r\n-  /// {@macro flutter.material.Material.clipBehavior}\r\n-  ///\r\n-  /// If this property is null, the [YExpansionTileThemeData.clipBehavior] is used. If that\r\n-  /// is also null, a [Clip.none] is used\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [YExpansionTileTheme.of], which returns the nearest [YExpansionTileTheme]'s\r\n-  ///   [YExpansionTileThemeData].\r\n-  final Clip? clipBehavior;\r\n-\r\n-  /// Typically used to force the expansion arrow icon to the tile's leading or trailing edge.\r\n-  ///\r\n-  /// By default, the value of [controlAffinity] is [ListTileControlAffinity.platform],\r\n-  /// which means that the expansion arrow icon will appear on the tile's trailing edge.\r\n-  final ListTileControlAffinity? controlAffinity;\r\n-\r\n-  /// If provided, the controller can be used to expand and collapse tiles.\r\n-  ///\r\n-  /// In cases were control over the tile's state is needed from a callback triggered\r\n-  /// by a widget within the tile, [YExpansionTileController.of] may be more convenient\r\n-  /// than supplying a controller.\r\n-  final YExpansionTileController? controller;\r\n-\r\n-  @override\r\n-  State<YExpansionTile> createState() => _YExpansionTileState();\r\n-}\r\n-\r\n-class _YExpansionTileState extends State<YExpansionTile>\r\n-    with SingleTickerProviderStateMixin {\r\n-  static final Animatable<double> _easeOutTween =\r\n-      CurveTween(curve: Curves.easeOut);\r\n-  static final Animatable<double> _easeInTween =\r\n-      CurveTween(curve: Curves.easeIn);\r\n-  static final Animatable<double> _halfTween =\r\n-      Tween<double>(begin: 0.0, end: 0.5);\r\n-\r\n-  final ShapeBorderTween _borderTween = ShapeBorderTween();\r\n-  final ColorTween _headerColorTween = ColorTween();\r\n-  final ColorTween _iconColorTween = ColorTween();\r\n-  final ColorTween _backgroundColorTween = ColorTween();\r\n-\r\n-  late AnimationController _animationController;\r\n-  late Animation<double> _iconTurns;\r\n-  late Animation<double> _heightFactor;\r\n-  late Animation<ShapeBorder?> _border;\r\n-  late Animation<Color?> _headerColor;\r\n-  late Animation<Color?> _iconColor;\r\n-  late Animation<Color?> _backgroundColor;\r\n-\r\n-  bool _isExpanded = false;\r\n-  late YExpansionTileController _tileController;\r\n-\r\n-  @override\r\n-  void initState() {\r\n-    super.initState();\r\n-    _animationController = AnimationController(duration: _kExpand, vsync: this);\r\n-    _heightFactor = _animationController.drive(_easeInTween);\r\n-    _iconTurns = _animationController.drive(_halfTween.chain(_easeInTween));\r\n-    _border = _animationController.drive(_borderTween.chain(_easeOutTween));\r\n-    _headerColor =\r\n-        _animationController.drive(_headerColorTween.chain(_easeInTween));\r\n-    _iconColor =\r\n-        _animationController.drive(_iconColorTween.chain(_easeInTween));\r\n-    _backgroundColor =\r\n-        _animationController.drive(_backgroundColorTween.chain(_easeOutTween));\r\n-\r\n-    _isExpanded = PageStorage.maybeOf(context)?.readState(context) as bool? ??\r\n-        widget.initiallyExpanded;\r\n-    if (_isExpanded) {\r\n-      _animationController.value = 1.0;\r\n-    }\r\n-\r\n-    assert(widget.controller?._state == null);\r\n-    _tileController = widget.controller ?? YExpansionTileController();\r\n-    _tileController._state = this;\r\n-  }\r\n-\r\n-  @override\r\n-  void dispose() {\r\n-    _tileController._state = null;\r\n-    _animationController.dispose();\r\n-    super.dispose();\r\n-  }\r\n-\r\n-  void _toggleExpansion() {\r\n-    setState(() {\r\n-      _isExpanded = !_isExpanded;\r\n-      if (_isExpanded) {\r\n-        _animationController.forward();\r\n-      } else {\r\n-        _animationController.reverse().then<void>((void value) {\r\n-          if (!mounted) {\r\n-            return;\r\n-          }\r\n-          setState(() {\r\n-            // Rebuild without widget.children.\r\n-          });\r\n-        });\r\n-      }\r\n-      PageStorage.maybeOf(context)?.writeState(context, _isExpanded);\r\n-    });\r\n-    widget.onExpansionChanged?.call(_isExpanded);\r\n-  }\r\n-\r\n-  void _handleTap() {\r\n-    _toggleExpansion();\r\n-  }\r\n-\r\n-  // Platform or null affinity defaults to trailing.\r\n-  ListTileControlAffinity _effectiveAffinity(\r\n-      ListTileControlAffinity? affinity) {\r\n-    switch (affinity ?? ListTileControlAffinity.trailing) {\r\n-      case ListTileControlAffinity.leading:\r\n-        return ListTileControlAffinity.leading;\r\n-      case ListTileControlAffinity.trailing:\r\n-      case ListTileControlAffinity.platform:\r\n-        return ListTileControlAffinity.trailing;\r\n-    }\r\n-  }\r\n-\r\n-  Widget? _buildIcon(BuildContext context) {\r\n-    return RotationTransition(\r\n-      turns: _iconTurns,\r\n-      child: const Icon(Icons.expand_more),\r\n-    );\r\n-  }\r\n-\r\n-  Widget? _buildLeadingIcon(BuildContext context) {\r\n-    if (_effectiveAffinity(widget.controlAffinity) !=\r\n-        ListTileControlAffinity.leading) {\r\n-      return null;\r\n-    }\r\n-    return _buildIcon(context);\r\n-  }\r\n-\r\n-  Widget? _buildTrailingIcon(BuildContext context) {\r\n-    if (_effectiveAffinity(widget.controlAffinity) !=\r\n-        ListTileControlAffinity.trailing) {\r\n-      return null;\r\n-    }\r\n-    return _buildIcon(context);\r\n-  }\r\n-\r\n-  Widget _buildChildren(BuildContext context, Widget? child) {\r\n-    final YExpansionTileThemeData YexpansionTileTheme =\r\n-        YExpansionTileTheme.of(context);\r\n-    final ShapeBorder YexpansionTileBorder = _border.value ??\r\n-        const Border(\r\n-          top: BorderSide(color: Colors.transparent),\r\n-          bottom: BorderSide(color: Colors.transparent),\r\n-        );\r\n-    final Clip clipBehavior =\r\n-        widget.clipBehavior ?? YexpansionTileTheme.clipBehavior ?? Clip.none;\r\n-\r\n-    return Container(\r\n-      clipBehavior: clipBehavior,\r\n-      decoration: ShapeDecoration(\r\n-        color: _backgroundColor.value ??\r\n-            YexpansionTileTheme.backgroundColor ??\r\n-            Colors.transparent,\r\n-        shape: YexpansionTileBorder,\r\n-      ),\r\n-      child: Column(\r\n-        mainAxisSize: MainAxisSize.min,\r\n-        children: <Widget>[\r\n-          ListTileTheme.merge(\r\n-            iconColor: _iconColor.value ?? YexpansionTileTheme.iconColor,\r\n-            textColor: _headerColor.value,\r\n-            child: ListTile(\r\n-              onTap: _handleTap,\r\n-              contentPadding:\r\n-                  widget.tilePadding ?? YexpansionTileTheme.tilePadding,\r\n-              leading: widget.leading ?? _buildLeadingIcon(context),\r\n-              title: widget.title,\r\n-              subtitle: widget.subtitle,\r\n-              trailing: widget.trailing ?? _buildTrailingIcon(context),\r\n-            ),\r\n-          ),\r\n-          ClipRect(\r\n-            child: Align(\r\n-              alignment: widget.expandedAlignment ??\r\n-                  YexpansionTileTheme.expandedAlignment ??\r\n-                  Alignment.center,\r\n-              heightFactor: _heightFactor.value,\r\n-              child: child,\r\n-            ),\r\n-          ),\r\n-        ],\r\n-      ),\r\n-    );\r\n-  }\r\n-\r\n-  @override\r\n-  void didChangeDependencies() {\r\n-    final ThemeData theme = Theme.of(context);\r\n-    final YExpansionTileThemeData YexpansionTileTheme =\r\n-        YExpansionTileTheme.of(context);\r\n-    final YExpansionTileThemeData defaults = theme.useMaterial3\r\n-        ? _YExpansionTileDefaultsM3(context)\r\n-        : _YExpansionTileDefaultsM2(context);\r\n-    _borderTween\r\n-      ..begin = widget.collapsedShape ??\r\n-          YexpansionTileTheme.collapsedShape ??\r\n-          const Border(\r\n-            top: BorderSide(color: Colors.transparent),\r\n-            bottom: BorderSide(color: Colors.transparent),\r\n-          )\r\n-      ..end = widget.shape ??\r\n-          YexpansionTileTheme.collapsedShape ??\r\n-          Border(\r\n-            top: BorderSide(color: theme.dividerColor),\r\n-            bottom: BorderSide(color: theme.dividerColor),\r\n-          );\r\n-    _headerColorTween\r\n-      ..begin = widget.collapsedTextColor ??\r\n-          YexpansionTileTheme.collapsedTextColor ??\r\n-          defaults.collapsedTextColor\r\n-      ..end = widget.textColor ??\r\n-          YexpansionTileTheme.textColor ??\r\n-          defaults.textColor;\r\n-    _iconColorTween\r\n-      ..begin = widget.collapsedIconColor ??\r\n-          YexpansionTileTheme.collapsedIconColor ??\r\n-          defaults.collapsedIconColor\r\n-      ..end = widget.iconColor ??\r\n-          YexpansionTileTheme.iconColor ??\r\n-          defaults.iconColor;\r\n-    _backgroundColorTween\r\n-      ..begin = widget.collapsedBackgroundColor ??\r\n-          YexpansionTileTheme.collapsedBackgroundColor\r\n-      ..end = widget.backgroundColor ?? YexpansionTileTheme.backgroundColor;\r\n-    super.didChangeDependencies();\r\n-  }\r\n-\r\n-  @override\r\n-  Widget build(BuildContext context) {\r\n-    final YExpansionTileThemeData YexpansionTileTheme =\r\n-        YExpansionTileTheme.of(context);\r\n-    final bool closed = !_isExpanded && _animationController.isDismissed;\r\n-    final bool shouldRemoveChildren = closed && !widget.maintainState;\r\n-\r\n-    final Widget result = Offstage(\r\n-      offstage: closed,\r\n-      child: TickerMode(\r\n-        enabled: !closed,\r\n-        child: Padding(\r\n-          padding: widget.childrenPadding ??\r\n-              YexpansionTileTheme.childrenPadding ??\r\n-              EdgeInsets.zero,\r\n-          child: Column(\r\n-            crossAxisAlignment:\r\n-                widget.expandedCrossAxisAlignment ?? CrossAxisAlignment.center,\r\n-            children: widget.children,\r\n-          ),\r\n-        ),\r\n-      ),\r\n-    );\r\n-\r\n-    return AnimatedBuilder(\r\n-      animation: _animationController.view,\r\n-      builder: _buildChildren,\r\n-      child: shouldRemoveChildren ? null : result,\r\n-    );\r\n-  }\r\n-}\r\n-\r\n-class _YExpansionTileDefaultsM2 extends YExpansionTileThemeData {\r\n-  _YExpansionTileDefaultsM2(this.context);\r\n-\r\n-  final BuildContext context;\r\n-  late final ThemeData _theme = Theme.of(context);\r\n-  late final ColorScheme _colorScheme = _theme.colorScheme;\r\n-\r\n-  @override\r\n-  Color? get textColor => _colorScheme.primary;\r\n-\r\n-  @override\r\n-  Color? get iconColor => _colorScheme.primary;\r\n-\r\n-  @override\r\n-  Color? get collapsedTextColor => _theme.textTheme.titleMedium!.color;\r\n-\r\n-  @override\r\n-  Color? get collapsedIconColor => _theme.unselectedWidgetColor;\r\n-}\r\n-\r\n-// BEGIN GENERATED TOKEN PROPERTIES - YExpansionTile\r\n-\r\n-// Do not edit by hand. The code between the \"BEGIN GENERATED\" and\r\n-// \"END GENERATED\" comments are generated from data in the Material\r\n-// Design token database by the script:\r\n-//   dev/tools/gen_defaults/bin/gen_defaults.dart.\r\n-\r\n-// Token database version: v0_162\r\n-\r\n-class _YExpansionTileDefaultsM3 extends YExpansionTileThemeData {\r\n-  _YExpansionTileDefaultsM3(this.context);\r\n-\r\n-  final BuildContext context;\r\n-  late final ThemeData _theme = Theme.of(context);\r\n-  late final ColorScheme _colors = _theme.colorScheme;\r\n-\r\n-  @override\r\n-  Color? get textColor => _colors.onSurface;\r\n-\r\n-  @override\r\n-  Color? get iconColor => _colors.primary;\r\n-\r\n-  @override\r\n-  Color? get collapsedTextColor => _colors.onSurface;\r\n-\r\n-  @override\r\n-  Color? get collapsedIconColor => _colors.onSurfaceVariant;\r\n-}\r\n-\r\n-// END GENERATED TOKEN PROPERTIES - YExpansionTile\r\n-// Copyright 2014 The Flutter Authors. All rights reserved.\r\n-// Use of this source code is governed by a BSD-style license that can be\r\n-// found in the LICENSE file.\r\n-\r\n-import 'package:flutter/widgets.dart';\r\n-\r\n-import 'color_scheme.dart';\r\n-import 'colors.dart';\r\n-import 'expansion_tile_theme.dart';\r\n-import 'icons.dart';\r\n-import 'list_tile.dart';\r\n-import 'list_tile_theme.dart';\r\n-import 'material.dart';\r\n-import 'theme.dart';\r\n-\r\n-const Duration _kExpand = Duration(milliseconds: 200);\r\n-\r\n-/// Enables control over a single [ExpansionTile]'s expanded/collapsed state.\r\n-///\r\n-/// It can be useful to expand or collapse an [ExpansionTile]\r\n-/// programatically, for example to reconfigure an existing expansion\r\n-/// tile based on a system event. To do so, create an [ExpansionTile]\r\n-/// with an [ExpansionTileController] that's owned by a stateful widget\r\n-/// or look up the tile's automatically created [ExpansionTileController]\r\n-/// with [ExpansionTileController.of]\r\n-///\r\n-/// The controller's [expand] and [collapse] methods cause the\r\n-/// the [ExpansionTile] to rebuild, so they may not be called from\r\n-/// a build method.\r\n-class ExpansionTileController {\r\n-  /// Create a controller to be used with [ExpansionTile.controller].\r\n-  ExpansionTileController();\r\n-\r\n-  _ExpansionTileState? _state;\r\n-\r\n-  /// Whether the [ExpansionTile] built with this controller is in expanded state.\r\n-  ///\r\n-  /// This property doesn't take the animation into account. It reports `true`\r\n-  /// even if the expansion animation is not completed.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  ///  * [expand], which expands the [ExpansionTile].\r\n-  ///  * [collapse], which collapses the [ExpansionTile].\r\n-  ///  * [ExpansionTile.controller] to create an ExpansionTile with a controller.\r\n-  bool get isExpanded {\r\n-    assert(_state != null);\r\n-    return _state!._isExpanded;\r\n-  }\r\n-\r\n-  /// Expands the [ExpansionTile] that was built with this controller;\r\n-  ///\r\n-  /// Normally the tile is expanded automatically when the user taps on the header.\r\n-  /// It is sometimes useful to trigger the expansion programmatically due\r\n-  /// to external changes.\r\n-  ///\r\n-  /// If the tile is already in the expanded state (see [isExpanded]), calling\r\n-  /// this method has no effect.\r\n-  ///\r\n-  /// Calling this method may cause the [ExpansionTile] to rebuild, so it may\r\n-  /// not be called from a build method.\r\n-  ///\r\n-  /// Calling this method will trigger an [ExpansionTile.onExpansionChanged] callback.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  ///  * [collapse], which collapses the tile.\r\n-  ///  * [isExpanded] to check whether the tile is expanded.\r\n-  ///  * [ExpansionTile.controller] to create an ExpansionTile with a controller.\r\n-  void expand() {\r\n-    assert(_state != null);\r\n-    if (!isExpanded) {\r\n-      _state!._toggleExpansion();\r\n-    }\r\n-  }\r\n-\r\n-  /// Collapses the [ExpansionTile] that was built with this controller.\r\n-  ///\r\n-  /// Normally the tile is collapsed automatically when the user taps on the header.\r\n-  /// It can be useful sometimes to trigger the collapse programmatically due\r\n-  /// to some external changes.\r\n-  ///\r\n-  /// If the tile is already in the collapsed state (see [isExpanded]), calling\r\n-  /// this method has no effect.\r\n-  ///\r\n-  /// Calling this method may cause the [ExpansionTile] to rebuild, so it may\r\n-  /// not be called from a build method.\r\n-  ///\r\n-  /// Calling this method will trigger an [ExpansionTile.onExpansionChanged] callback.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  ///  * [expand], which expands the tile.\r\n-  ///  * [isExpanded] to check whether the tile is expanded.\r\n-  ///  * [ExpansionTile.controller] to create an ExpansionTile with a controller.\r\n-  void collapse() {\r\n-    assert(_state != null);\r\n-    if (isExpanded) {\r\n-      _state!._toggleExpansion();\r\n-    }\r\n-  }\r\n-\r\n-  /// Finds the [ExpansionTileController] for the closest [ExpansionTile] instance\r\n-  /// that encloses the given context.\r\n-  ///\r\n-  /// If no [ExpansionTile] encloses the given context, calling this\r\n-  /// method will cause an assert in debug mode, and throw an\r\n-  /// exception in release mode.\r\n-  ///\r\n-  /// To return null if there is no [ExpansionTile] use [maybeOf] instead.\r\n-  ///\r\n-  /// {@tool dartpad}\r\n-  /// Typical usage of the [ExpansionTileController.of] function is to call it from within the\r\n-  /// `build` method of a descendant of an [ExpansionTile].\r\n-  ///\r\n-  /// When the [ExpansionTile] is actually created in the same `build`\r\n-  /// function as the callback that refers to the controller, then the\r\n-  /// `context` argument to the `build` function can't be used to find\r\n-  /// the [ExpansionTileController] (since it's \"above\" the widget\r\n-  /// being returned in the widget tree). In cases like that you can\r\n-  /// add a [Builder] widget, which provides a new scope with a\r\n-  /// [BuildContext] that is \"under\" the [ExpansionTile]:\r\n-  ///\r\n-  /// ** See code in examples/api/lib/material/expansion_tile/expansion_tile.1.dart **\r\n-  /// {@end-tool}\r\n-  ///\r\n-  /// A more efficient solution is to split your build function into\r\n-  /// several widgets. This introduces a new context from which you\r\n-  /// can obtain the [ExpansionTileController]. With this approach you\r\n-  /// would have an outer widget that creates the [ExpansionTile]\r\n-  /// populated by instances of your new inner widgets, and then in\r\n-  /// these inner widgets you would use [ExpansionTileController.of].\r\n-  static ExpansionTileController of(BuildContext context) {\r\n-    final _ExpansionTileState? result =\r\n-        context.findAncestorStateOfType<_ExpansionTileState>();\r\n-    if (result != null) {\r\n-      return result._tileController;\r\n-    }\r\n-    throw FlutterError.fromParts(<DiagnosticsNode>[\r\n-      ErrorSummary(\r\n-        'ExpansionTileController.of() called with a context that does not contain a ExpansionTile.',\r\n-      ),\r\n-      ErrorDescription(\r\n-        'No ExpansionTile ancestor could be found starting from the context that was passed to ExpansionTileController.of(). '\r\n-        'This usually happens when the context provided is from the same StatefulWidget as that '\r\n-        'whose build function actually creates the ExpansionTile widget being sought.',\r\n-      ),\r\n-      ErrorHint(\r\n-        'There are several ways to avoid this problem. The simplest is to use a Builder to get a '\r\n-        'context that is \"under\" the ExpansionTile. For an example of this, please see the '\r\n-        'documentation for ExpansionTileController.of():\\n'\r\n-        '  https://api.flutter.dev/flutter/material/ExpansionTile/of.html',\r\n-      ),\r\n-      ErrorHint(\r\n-        'A more efficient solution is to split your build function into several widgets. This '\r\n-        'introduces a new context from which you can obtain the ExpansionTile. In this solution, '\r\n-        'you would have an outer widget that creates the ExpansionTile populated by instances of '\r\n-        'your new inner widgets, and then in these inner widgets you would use ExpansionTileController.of().\\n'\r\n-        'An other solution is assign a GlobalKey to the ExpansionTile, '\r\n-        'then use the key.currentState property to obtain the ExpansionTile rather than '\r\n-        'using the ExpansionTileController.of() function.',\r\n-      ),\r\n-      context.describeElement('The context used was'),\r\n-    ]);\r\n-  }\r\n-\r\n-  /// Finds the [ExpansionTile] from the closest instance of this class that\r\n-  /// encloses the given context and returns its [ExpansionTileController].\r\n-  ///\r\n-  /// If no [ExpansionTile] encloses the given context then return null.\r\n-  /// To throw an exception instead, use [of] instead of this function.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  ///  * [of], a similar function to this one that throws if no [ExpansionTile]\r\n-  ///    encloses the given context. Also includes some sample code in its\r\n-  ///    documentation.\r\n-  static ExpansionTileController? maybeOf(BuildContext context) {\r\n-    return context\r\n-        .findAncestorStateOfType<_ExpansionTileState>()\r\n-        ?._tileController;\r\n-  }\r\n-}\r\n-\r\n-/// A single-line [ListTile] with an expansion arrow icon that expands or collapses\r\n-/// the tile to reveal or hide the [children].\r\n-///\r\n-/// This widget is typically used with [ListView] to create an\r\n-/// \"expand / collapse\" list entry. When used with scrolling widgets like\r\n-/// [ListView], a unique [PageStorageKey] must be specified to enable the\r\n-/// [ExpansionTile] to save and restore its expanded state when it is scrolled\r\n-/// in and out of view.\r\n-///\r\n-/// This class overrides the [ListTileThemeData.iconColor] and [ListTileThemeData.textColor]\r\n-/// theme properties for its [ListTile]. These colors animate between values when\r\n-/// the tile is expanded and collapsed: between [iconColor], [collapsedIconColor] and\r\n-/// between [textColor] and [collapsedTextColor].\r\n-///\r\n-/// The expansion arrow icon is shown on the right by default in left-to-right languages\r\n-/// (i.e. the trailing edge). This can be changed using [controlAffinity]. This maps\r\n-/// to the [leading] and [trailing] properties of [ExpansionTile].\r\n-///\r\n-/// {@tool dartpad}\r\n-/// This example demonstrates how the [ExpansionTile] icon's location and appearance\r\n-/// can be customized.\r\n-///\r\n-/// ** See code in examples/api/lib/material/expansion_tile/expansion_tile.0.dart **\r\n-/// {@end-tool}\r\n-///\r\n-/// {@tool dartpad}\r\n-/// This example demonstrates how an [ExpansionTileController] can be used to\r\n-/// programatically expand or collapse an [ExpansionTile].\r\n-///\r\n-/// ** See code in examples/api/lib/material/expansion_tile/expansion_tile.1.dart **\r\n-/// {@end-tool}\r\n-///\r\n-/// See also:\r\n-///\r\n-///  * [ListTile], useful for creating expansion tile [children] when the\r\n-///    expansion tile represents a sublist.\r\n-///  * The \"Expand and collapse\" section of\r\n-///    <https://material.io/components/lists#types>\r\n-class ExpansionTile extends StatefulWidget {\r\n-  /// Creates a single-line [ListTile] with an expansion arrow icon that expands or collapses\r\n-  /// the tile to reveal or hide the [children]. The [initiallyExpanded] property must\r\n-  /// be non-null.\r\n-  const ExpansionTile({\r\n-    super.key,\r\n-    this.leading,\r\n-    required this.title,\r\n-    this.subtitle,\r\n-    this.onExpansionChanged,\r\n-    this.children = const <Widget>[],\r\n-    this.trailing,\r\n-    this.initiallyExpanded = false,\r\n-    this.maintainState = false,\r\n-    this.tilePadding,\r\n-    this.expandedCrossAxisAlignment,\r\n-    this.expandedAlignment,\r\n-    this.childrenPadding,\r\n-    this.backgroundColor,\r\n-    this.collapsedBackgroundColor,\r\n-    this.textColor,\r\n-    this.collapsedTextColor,\r\n-    this.iconColor,\r\n-    this.collapsedIconColor,\r\n-    this.shape,\r\n-    this.collapsedShape,\r\n-    this.clipBehavior,\r\n-    this.controlAffinity,\r\n-    this.controller,\r\n-  }) : assert(\r\n-          expandedCrossAxisAlignment != CrossAxisAlignment.baseline,\r\n-          'CrossAxisAlignment.baseline is not supported since the expanded children '\r\n-          'are aligned in a column, not a row. Try to use another constant.',\r\n-        );\r\n-\r\n-  /// A widget to display before the title.\r\n-  ///\r\n-  /// Typically a [CircleAvatar] widget.\r\n-  ///\r\n-  /// Depending on the value of [controlAffinity], the [leading] widget\r\n-  /// may replace the rotating expansion arrow icon.\r\n-  final Widget? leading;\r\n-\r\n-  /// The primary content of the list item.\r\n-  ///\r\n-  /// Typically a [Text] widget.\r\n-  final Widget title;\r\n-\r\n-  /// Additional content displayed below the title.\r\n-  ///\r\n-  /// Typically a [Text] widget.\r\n-  final Widget? subtitle;\r\n-\r\n-  /// Called when the tile expands or collapses.\r\n-  ///\r\n-  /// When the tile starts expanding, this function is called with the value\r\n-  /// true. When the tile starts collapsing, this function is called with\r\n-  /// the value false.\r\n-  final ValueChanged<bool>? onExpansionChanged;\r\n-\r\n-  /// The widgets that are displayed when the tile expands.\r\n-  ///\r\n-  /// Typically [ListTile] widgets.\r\n-  final List<Widget> children;\r\n-\r\n-  /// The color to display behind the sublist when expanded.\r\n-  ///\r\n-  /// If this property is null then [ExpansionTileThemeData.backgroundColor] is used. If that\r\n-  /// is also null then Colors.transparent is used.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s\r\n-  ///   [ExpansionTileThemeData].\r\n-  final Color? backgroundColor;\r\n-\r\n-  /// When not null, defines the background color of tile when the sublist is collapsed.\r\n-  ///\r\n-  /// If this property is null then [ExpansionTileThemeData.collapsedBackgroundColor] is used.\r\n-  /// If that is also null then Colors.transparent is used.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s\r\n-  ///   [ExpansionTileThemeData].\r\n-  final Color? collapsedBackgroundColor;\r\n-\r\n-  /// A widget to display after the title.\r\n-  ///\r\n-  /// Depending on the value of [controlAffinity], the [trailing] widget\r\n-  /// may replace the rotating expansion arrow icon.\r\n-  final Widget? trailing;\r\n-\r\n-  /// Specifies if the list tile is initially expanded (true) or collapsed (false, the default).\r\n-  final bool initiallyExpanded;\r\n-\r\n-  /// Specifies whether the state of the children is maintained when the tile expands and collapses.\r\n-  ///\r\n-  /// When true, the children are kept in the tree while the tile is collapsed.\r\n-  /// When false (default), the children are removed from the tree when the tile is\r\n-  /// collapsed and recreated upon expansion.\r\n-  final bool maintainState;\r\n-\r\n-  /// Specifies padding for the [ListTile].\r\n-  ///\r\n-  /// Analogous to [ListTile.contentPadding], this property defines the insets for\r\n-  /// the [leading], [title], [subtitle] and [trailing] widgets. It does not inset\r\n-  /// the expanded [children] widgets.\r\n-  ///\r\n-  /// If this property is null then [ExpansionTileThemeData.tilePadding] is used. If that\r\n-  /// is also null then the tile's padding is `EdgeInsets.symmetric(horizontal: 16.0)`.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s\r\n-  ///   [ExpansionTileThemeData].\r\n-  final EdgeInsetsGeometry? tilePadding;\r\n-\r\n-  /// Specifies the alignment of [children], which are arranged in a column when\r\n-  /// the tile is expanded.\r\n-  ///\r\n-  /// The internals of the expanded tile make use of a [Column] widget for\r\n-  /// [children], and [Align] widget to align the column. The [expandedAlignment]\r\n-  /// parameter is passed directly into the [Align].\r\n-  ///\r\n-  /// Modifying this property controls the alignment of the column within the\r\n-  /// expanded tile, not the alignment of [children] widgets within the column.\r\n-  /// To align each child within [children], see [expandedCrossAxisAlignment].\r\n-  ///\r\n-  /// The width of the column is the width of the widest child widget in [children].\r\n-  ///\r\n-  /// If this property is null then [ExpansionTileThemeData.expandedAlignment]is used. If that\r\n-  /// is also null then the value of [expandedAlignment] is [Alignment.center].\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s\r\n-  ///   [ExpansionTileThemeData].\r\n-  final Alignment? expandedAlignment;\r\n-\r\n-  /// Specifies the alignment of each child within [children] when the tile is expanded.\r\n-  ///\r\n-  /// The internals of the expanded tile make use of a [Column] widget for\r\n-  /// [children], and the `crossAxisAlignment` parameter is passed directly into\r\n-  /// the [Column].\r\n-  ///\r\n-  /// Modifying this property controls the cross axis alignment of each child\r\n-  /// within its [Column]. The width of the [Column] that houses [children] will\r\n-  /// be the same as the widest child widget in [children]. The width of the\r\n-  /// [Column] might not be equal to the width of the expanded tile.\r\n-  ///\r\n-  /// To align the [Column] along the expanded tile, use the [expandedAlignment]\r\n-  /// property instead.\r\n-  ///\r\n-  /// When the value is null, the value of [expandedCrossAxisAlignment] is\r\n-  /// [CrossAxisAlignment.center].\r\n-  final CrossAxisAlignment? expandedCrossAxisAlignment;\r\n-\r\n-  /// Specifies padding for [children].\r\n-  ///\r\n-  /// If this property is null then [ExpansionTileThemeData.childrenPadding] is used. If that\r\n-  /// is also null then the value of [childrenPadding] is [EdgeInsets.zero].\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s\r\n-  ///   [ExpansionTileThemeData].\r\n-  final EdgeInsetsGeometry? childrenPadding;\r\n-\r\n-  /// The icon color of tile's expansion arrow icon when the sublist is expanded.\r\n-  ///\r\n-  /// Used to override to the [ListTileThemeData.iconColor].\r\n-  ///\r\n-  /// If this property is null then [ExpansionTileThemeData.iconColor] is used. If that\r\n-  /// is also null then the value of [ColorScheme.primary] is used.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s\r\n-  ///   [ExpansionTileThemeData].\r\n-  final Color? iconColor;\r\n-\r\n-  /// The icon color of tile's expansion arrow icon when the sublist is collapsed.\r\n-  ///\r\n-  /// Used to override to the [ListTileThemeData.iconColor].\r\n-  ///\r\n-  /// If this property is null then [ExpansionTileThemeData.collapsedIconColor] is used. If that\r\n-  /// is also null and [ThemeData.useMaterial3] is true, [ColorScheme.onSurface] is used. Otherwise,\r\n-  /// defaults to [ThemeData.unselectedWidgetColor] color.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s\r\n-  ///   [ExpansionTileThemeData].\r\n-  final Color? collapsedIconColor;\r\n-\r\n-  /// The color of the tile's titles when the sublist is expanded.\r\n-  ///\r\n-  /// Used to override to the [ListTileThemeData.textColor].\r\n-  ///\r\n-  /// If this property is null then [ExpansionTileThemeData.textColor] is used. If that\r\n-  /// is also null then and [ThemeData.useMaterial3] is true, color of the [TextTheme.bodyLarge]\r\n-  /// will be used for the [title] and [subtitle]. Otherwise, defaults to [ColorScheme.primary] color.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s\r\n-  ///   [ExpansionTileThemeData].\r\n-  final Color? textColor;\r\n-\r\n-  /// The color of the tile's titles when the sublist is collapsed.\r\n-  ///\r\n-  /// Used to override to the [ListTileThemeData.textColor].\r\n-  ///\r\n-  /// If this property is null then [ExpansionTileThemeData.collapsedTextColor] is used.\r\n-  /// If that is also null and [ThemeData.useMaterial3] is true, color of the\r\n-  /// [TextTheme.bodyLarge] will be used for the [title] and [subtitle]. Otherwise,\r\n-  /// defaults to color of the [TextTheme.titleMedium].\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s\r\n-  ///   [ExpansionTileThemeData].\r\n-  final Color? collapsedTextColor;\r\n-\r\n-  /// The tile's border shape when the sublist is expanded.\r\n-  ///\r\n-  /// If this property is null, the [ExpansionTileThemeData.shape] is used. If that\r\n-  /// is also null, a [Border] with vertical sides default to [ThemeData.dividerColor] is used\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s\r\n-  ///   [ExpansionTileThemeData].\r\n-  final ShapeBorder? shape;\r\n-\r\n-  /// The tile's border shape when the sublist is collapsed.\r\n-  ///\r\n-  /// If this property is null, the [ExpansionTileThemeData.collapsedShape] is used. If that\r\n-  /// is also null, a [Border] with vertical sides default to Color [Colors.transparent] is used\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s\r\n-  ///   [ExpansionTileThemeData].\r\n-  final ShapeBorder? collapsedShape;\r\n-\r\n-  /// {@macro flutter.material.Material.clipBehavior}\r\n-  ///\r\n-  /// If this property is null, the [ExpansionTileThemeData.clipBehavior] is used. If that\r\n-  /// is also null, a [Clip.none] is used\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s\r\n-  ///   [ExpansionTileThemeData].\r\n-  final Clip? clipBehavior;\r\n-\r\n-  /// Typically used to force the expansion arrow icon to the tile's leading or trailing edge.\r\n-  ///\r\n-  /// By default, the value of [controlAffinity] is [ListTileControlAffinity.platform],\r\n-  /// which means that the expansion arrow icon will appear on the tile's trailing edge.\r\n-  final ListTileControlAffinity? controlAffinity;\r\n-\r\n-  /// If provided, the controller can be used to expand and collapse tiles.\r\n-  ///\r\n-  /// In cases were control over the tile's state is needed from a callback triggered\r\n-  /// by a widget within the tile, [ExpansionTileController.of] may be more convenient\r\n-  /// than supplying a controller.\r\n-  final ExpansionTileController? controller;\r\n-\r\n-  @override\r\n-  State<ExpansionTile> createState() => _ExpansionTileState();\r\n-}\r\n-\r\n-class _ExpansionTileState extends State<ExpansionTile>\r\n-    with SingleTickerProviderStateMixin {\r\n-  static final Animatable<double> _easeOutTween =\r\n-      CurveTween(curve: Curves.easeOut);\r\n-  static final Animatable<double> _easeInTween =\r\n-      CurveTween(curve: Curves.easeIn);\r\n-  static final Animatable<double> _halfTween =\r\n-      Tween<double>(begin: 0.0, end: 0.5);\r\n-\r\n-  final ShapeBorderTween _borderTween = ShapeBorderTween();\r\n-  final ColorTween _headerColorTween = ColorTween();\r\n-  final ColorTween _iconColorTween = ColorTween();\r\n-  final ColorTween _backgroundColorTween = ColorTween();\r\n-\r\n-  late AnimationController _animationController;\r\n-  late Animation<double> _iconTurns;\r\n-  late Animation<double> _heightFactor;\r\n-  late Animation<ShapeBorder?> _border;\r\n-  late Animation<Color?> _headerColor;\r\n-  late Animation<Color?> _iconColor;\r\n-  late Animation<Color?> _backgroundColor;\r\n-\r\n-  bool _isExpanded = false;\r\n-  late ExpansionTileController _tileController;\r\n-\r\n-  @override\r\n-  void initState() {\r\n-    super.initState();\r\n-    _animationController = AnimationController(duration: _kExpand, vsync: this);\r\n-    _heightFactor = _animationController.drive(_easeInTween);\r\n-    _iconTurns = _animationController.drive(_halfTween.chain(_easeInTween));\r\n-    _border = _animationController.drive(_borderTween.chain(_easeOutTween));\r\n-    _headerColor =\r\n-        _animationController.drive(_headerColorTween.chain(_easeInTween));\r\n-    _iconColor =\r\n-        _animationController.drive(_iconColorTween.chain(_easeInTween));\r\n-    _backgroundColor =\r\n-        _animationController.drive(_backgroundColorTween.chain(_easeOutTween));\r\n-\r\n-    _isExpanded = PageStorage.maybeOf(context)?.readState(context) as bool? ??\r\n-        widget.initiallyExpanded;\r\n-    if (_isExpanded) {\r\n-      _animationController.value = 1.0;\r\n-    }\r\n-\r\n-    assert(widget.controller?._state == null);\r\n-    _tileController = widget.controller ?? ExpansionTileController();\r\n-    _tileController._state = this;\r\n-  }\r\n-\r\n-  @override\r\n-  void dispose() {\r\n-    _tileController._state = null;\r\n-    _animationController.dispose();\r\n-    super.dispose();\r\n-  }\r\n-\r\n-  void _toggleExpansion() {\r\n-    setState(() {\r\n-      _isExpanded = !_isExpanded;\r\n-      if (_isExpanded) {\r\n-        _animationController.forward();\r\n-      } else {\r\n-        _animationController.reverse().then<void>((void value) {\r\n-          if (!mounted) {\r\n-            return;\r\n-          }\r\n-          setState(() {\r\n-            // Rebuild without widget.children.\r\n-          });\r\n-        });\r\n-      }\r\n-      PageStorage.maybeOf(context)?.writeState(context, _isExpanded);\r\n-    });\r\n-    widget.onExpansionChanged?.call(_isExpanded);\r\n-  }\r\n-\r\n-  void _handleTap() {\r\n-    _toggleExpansion();\r\n-  }\r\n-\r\n-  // Platform or null affinity defaults to trailing.\r\n-  ListTileControlAffinity _effectiveAffinity(\r\n-      ListTileControlAffinity? affinity) {\r\n-    switch (affinity ?? ListTileControlAffinity.trailing) {\r\n-      case ListTileControlAffinity.leading:\r\n-        return ListTileControlAffinity.leading;\r\n-      case ListTileControlAffinity.trailing:\r\n-      case ListTileControlAffinity.platform:\r\n-        return ListTileControlAffinity.trailing;\r\n-    }\r\n-  }\r\n-\r\n-  Widget? _buildIcon(BuildContext context) {\r\n-    return RotationTransition(\r\n-      turns: _iconTurns,\r\n-      child: const Icon(Icons.expand_more),\r\n-    );\r\n-  }\r\n-\r\n-  Widget? _buildLeadingIcon(BuildContext context) {\r\n-    if (_effectiveAffinity(widget.controlAffinity) !=\r\n-        ListTileControlAffinity.leading) {\r\n-      return null;\r\n-    }\r\n-    return _buildIcon(context);\r\n-  }\r\n-\r\n-  Widget? _buildTrailingIcon(BuildContext context) {\r\n-    if (_effectiveAffinity(widget.controlAffinity) !=\r\n-        ListTileControlAffinity.trailing) {\r\n-      return null;\r\n-    }\r\n-    return _buildIcon(context);\r\n-  }\r\n-\r\n-  Widget _buildChildren(BuildContext context, Widget? child) {\r\n-    final ExpansionTileThemeData expansionTileTheme =\r\n-        ExpansionTileTheme.of(context);\r\n-    final ShapeBorder expansionTileBorder = _border.value ??\r\n-        const Border(\r\n-          top: BorderSide(color: Colors.transparent),\r\n-          bottom: BorderSide(color: Colors.transparent),\r\n-        );\r\n-    final Clip clipBehavior =\r\n-        widget.clipBehavior ?? expansionTileTheme.clipBehavior ?? Clip.none;\r\n-\r\n-    return Container(\r\n-      clipBehavior: clipBehavior,\r\n-      decoration: ShapeDecoration(\r\n-        color: _backgroundColor.value ??\r\n-            expansionTileTheme.backgroundColor ??\r\n-            Colors.transparent,\r\n-        shape: expansionTileBorder,\r\n-      ),\r\n-      child: Column(\r\n-        mainAxisSize: MainAxisSize.min,\r\n-        children: <Widget>[\r\n-          ListTileTheme.merge(\r\n-            iconColor: _iconColor.value ?? expansionTileTheme.iconColor,\r\n-            textColor: _headerColor.value,\r\n-            child: ListTile(\r\n-              onTap: _handleTap,\r\n-              contentPadding:\r\n-                  widget.tilePadding ?? expansionTileTheme.tilePadding,\r\n-              leading: widget.leading ?? _buildLeadingIcon(context),\r\n-              title: widget.title,\r\n-              subtitle: widget.subtitle,\r\n-              trailing: widget.trailing ?? _buildTrailingIcon(context),\r\n-            ),\r\n-          ),\r\n-          ClipRect(\r\n-            child: Align(\r\n-              alignment: widget.expandedAlignment ??\r\n-                  expansionTileTheme.expandedAlignment ??\r\n-                  Alignment.center,\r\n-              heightFactor: _heightFactor.value,\r\n-              child: child,\r\n-            ),\r\n-          ),\r\n-        ],\r\n-      ),\r\n-    );\r\n-  }\r\n-\r\n-  @override\r\n-  void didChangeDependencies() {\r\n-    final ThemeData theme = Theme.of(context);\r\n-    final ExpansionTileThemeData expansionTileTheme =\r\n-        ExpansionTileTheme.of(context);\r\n-    final ExpansionTileThemeData defaults = theme.useMaterial3\r\n-        ? _ExpansionTileDefaultsM3(context)\r\n-        : _ExpansionTileDefaultsM2(context);\r\n-    _borderTween\r\n-      ..begin = widget.collapsedShape ??\r\n-          expansionTileTheme.collapsedShape ??\r\n-          const Border(\r\n-            top: BorderSide(color: Colors.transparent),\r\n-            bottom: BorderSide(color: Colors.transparent),\r\n-          )\r\n-      ..end = widget.shape ??\r\n-          expansionTileTheme.collapsedShape ??\r\n-          Border(\r\n-            top: BorderSide(color: theme.dividerColor),\r\n-            bottom: BorderSide(color: theme.dividerColor),\r\n-          );\r\n-    _headerColorTween\r\n-      ..begin = widget.collapsedTextColor ??\r\n-          expansionTileTheme.collapsedTextColor ??\r\n-          defaults.collapsedTextColor\r\n-      ..end = widget.textColor ??\r\n-          expansionTileTheme.textColor ??\r\n-          defaults.textColor;\r\n-    _iconColorTween\r\n-      ..begin = widget.collapsedIconColor ??\r\n-          expansionTileTheme.collapsedIconColor ??\r\n-          defaults.collapsedIconColor\r\n-      ..end = widget.iconColor ??\r\n-          expansionTileTheme.iconColor ??\r\n-          defaults.iconColor;\r\n-    _backgroundColorTween\r\n-      ..begin = widget.collapsedBackgroundColor ??\r\n-          expansionTileTheme.collapsedBackgroundColor\r\n-      ..end = widget.backgroundColor ?? expansionTileTheme.backgroundColor;\r\n-    super.didChangeDependencies();\r\n-  }\r\n-\r\n-  @override\r\n-  Widget build(BuildContext context) {\r\n-    final ExpansionTileThemeData expansionTileTheme =\r\n-        ExpansionTileTheme.of(context);\r\n-    final bool closed = !_isExpanded && _animationController.isDismissed;\r\n-    final bool shouldRemoveChildren = closed && !widget.maintainState;\r\n-\r\n-    final Widget result = Offstage(\r\n-      offstage: closed,\r\n-      child: TickerMode(\r\n-        enabled: !closed,\r\n-        child: Padding(\r\n-          padding: widget.childrenPadding ??\r\n-              expansionTileTheme.childrenPadding ??\r\n-              EdgeInsets.zero,\r\n-          child: Column(\r\n-            crossAxisAlignment:\r\n-                widget.expandedCrossAxisAlignment ?? CrossAxisAlignment.center,\r\n-            children: widget.children,\r\n-          ),\r\n-        ),\r\n-      ),\r\n-    );\r\n-\r\n-    return AnimatedBuilder(\r\n-      animation: _animationController.view,\r\n-      builder: _buildChildren,\r\n-      child: shouldRemoveChildren ? null : result,\r\n-    );\r\n-  }\r\n-}\r\n-\r\n-class _ExpansionTileDefaultsM2 extends ExpansionTileThemeData {\r\n-  _ExpansionTileDefaultsM2(this.context);\r\n-\r\n-  final BuildContext context;\r\n-  late final ThemeData _theme = Theme.of(context);\r\n-  late final ColorScheme _colorScheme = _theme.colorScheme;\r\n-\r\n-  @override\r\n-  Color? get textColor => _colorScheme.primary;\r\n-\r\n-  @override\r\n-  Color? get iconColor => _colorScheme.primary;\r\n-\r\n-  @override\r\n-  Color? get collapsedTextColor => _theme.textTheme.titleMedium!.color;\r\n-\r\n-  @override\r\n-  Color? get collapsedIconColor => _theme.unselectedWidgetColor;\r\n-}\r\n-\r\n-// BEGIN GENERATED TOKEN PROPERTIES - ExpansionTile\r\n-\r\n-// Do not edit by hand. The code between the \"BEGIN GENERATED\" and\r\n-// \"END GENERATED\" comments are generated from data in the Material\r\n-// Design token database by the script:\r\n-//   dev/tools/gen_defaults/bin/gen_defaults.dart.\r\n-\r\n-// Token database version: v0_162\r\n-\r\n-class _ExpansionTileDefaultsM3 extends ExpansionTileThemeData {\r\n-  _ExpansionTileDefaultsM3(this.context);\r\n-\r\n-  final BuildContext context;\r\n-  late final ThemeData _theme = Theme.of(context);\r\n-  late final ColorScheme _colors = _theme.colorScheme;\r\n-\r\n-  @override\r\n-  Color? get textColor => _colors.onSurface;\r\n-\r\n-  @override\r\n-  Color? get iconColor => _colors.primary;\r\n-\r\n-  @override\r\n-  Color? get collapsedTextColor => _colors.onSurface;\r\n-\r\n-  @override\r\n-  Color? get collapsedIconColor => _colors.onSurfaceVariant;\r\n-}\r\n-\r\n-// END GENERATED TOKEN PROPERTIES - ExpansionTile\r\n"
                },
                {
                    "date": 1694523184809,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,787 @@\n+// Copyright 2014 The Flutter Authors. All rights reserved.\r\n+// Use of this source code is governed by a BSD-style license that can be\r\n+// found in the LICENSE file.\r\n+\r\n+import 'package:flutter/material.dart';\r\n+import 'package:flutter/widgets.dart';\r\n+\r\n+import 'color_scheme.dart';\r\n+import 'colors.dart';\r\n+import 'expansion_tile_theme.dart';\r\n+import 'icons.dart';\r\n+import 'list_tile.dart';\r\n+import 'list_tile_theme.dart';\r\n+import 'material.dart';\r\n+import 'theme.dart';\r\n+\r\n+const Duration _kExpand = Duration(milliseconds: 200);\r\n+\r\n+/// Enables control over a single [MYExpansionTile]'s expanded/collapsed state.\r\n+///\r\n+/// It can be useful to expand or collapse an [MYExpansionTile]\r\n+/// programatically, for example to reconfigure an existing expansion\r\n+/// tile based on a system event. To do so, create an [MYExpansionTile]\r\n+/// with an [MYExpansionTileController] that's owned by a stateful widget\r\n+/// or look up the tile's automatically created [MYExpansionTileController]\r\n+/// with [MYExpansionTileController.of]\r\n+///\r\n+/// The controller's [expand] and [collapse] methods cause the\r\n+/// the [MYExpansionTile] to rebuild, so they may not be called from\r\n+/// a build method.\r\n+class MYExpansionTileController {\r\n+  /// Create a controller to be used with [MYExpansionTile.controller].\r\n+  MYExpansionTileController();\r\n+\r\n+  _MYExpansionTileState? _state;\r\n+\r\n+  /// Whether the [MYExpansionTile] built with this controller is in expanded state.\r\n+  ///\r\n+  /// This property doesn't take the animation into account. It reports `true`\r\n+  /// even if the expansion animation is not completed.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [expand], which expands the [MYExpansionTile].\r\n+  ///  * [collapse], which collapses the [MYExpansionTile].\r\n+  ///  * [MYExpansionTile.controller] to create an MYExpansionTile with a controller.\r\n+  bool get isExpanded {\r\n+    assert(_state != null);\r\n+    return _state!._isExpanded;\r\n+  }\r\n+\r\n+  /// Expands the [MYExpansionTile] that was built with this controller;\r\n+  ///\r\n+  /// Normally the tile is expanded automatically when the user taps on the header.\r\n+  /// It is sometimes useful to trigger the expansion programmatically due\r\n+  /// to external changes.\r\n+  ///\r\n+  /// If the tile is already in the expanded state (see [isExpanded]), calling\r\n+  /// this method has no effect.\r\n+  ///\r\n+  /// Calling this method may cause the [MYExpansionTile] to rebuild, so it may\r\n+  /// not be called from a build method.\r\n+  ///\r\n+  /// Calling this method will trigger an [MYExpansionTile.onExpansionChanged] callback.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [collapse], which collapses the tile.\r\n+  ///  * [isExpanded] to check whether the tile is expanded.\r\n+  ///  * [MYExpansionTile.controller] to create an MYExpansionTile with a controller.\r\n+  void expand() {\r\n+    assert(_state != null);\r\n+    if (!isExpanded) {\r\n+      _state!._toggleExpansion();\r\n+    }\r\n+  }\r\n+\r\n+  /// Collapses the [MYExpansionTile] that was built with this controller.\r\n+  ///\r\n+  /// Normally the tile is collapsed automatically when the user taps on the header.\r\n+  /// It can be useful sometimes to trigger the collapse programmatically due\r\n+  /// to some external changes.\r\n+  ///\r\n+  /// If the tile is already in the collapsed state (see [isExpanded]), calling\r\n+  /// this method has no effect.\r\n+  ///\r\n+  /// Calling this method may cause the [MYExpansionTile] to rebuild, so it may\r\n+  /// not be called from a build method.\r\n+  ///\r\n+  /// Calling this method will trigger an [MYExpansionTile.onExpansionChanged] callback.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [expand], which expands the tile.\r\n+  ///  * [isExpanded] to check whether the tile is expanded.\r\n+  ///  * [MYExpansionTile.controller] to create an MYExpansionTile with a controller.\r\n+  void collapse() {\r\n+    assert(_state != null);\r\n+    if (isExpanded) {\r\n+      _state!._toggleExpansion();\r\n+    }\r\n+  }\r\n+\r\n+  /// Finds the [MYExpansionTileController] for the closest [MYExpansionTile] instance\r\n+  /// that encloses the given context.\r\n+  ///\r\n+  /// If no [MYExpansionTile] encloses the given context, calling this\r\n+  /// method will cause an assert in debug mode, and throw an\r\n+  /// exception in release mode.\r\n+  ///\r\n+  /// To return null if there is no [MYExpansionTile] use [maybeOf] instead.\r\n+  ///\r\n+  /// {@tool dartpad}\r\n+  /// Typical usage of the [MYExpansionTileController.of] function is to call it from within the\r\n+  /// `build` method of a descendant of an [MYExpansionTile].\r\n+  ///\r\n+  /// When the [MYExpansionTile] is actually created in the same `build`\r\n+  /// function as the callback that refers to the controller, then the\r\n+  /// `context` argument to the `build` function can't be used to find\r\n+  /// the [MYExpansionTileController] (since it's \"above\" the widget\r\n+  /// being returned in the widget tree). In cases like that you can\r\n+  /// add a [Builder] widget, which provides a new scope with a\r\n+  /// [BuildContext] that is \"under\" the [MYExpansionTile]:\r\n+  ///\r\n+  /// ** See code in examples/api/lib/material/expansion_tile/expansion_tile.1.dart **\r\n+  /// {@end-tool}\r\n+  ///\r\n+  /// A more efficient solution is to split your build function into\r\n+  /// several widgets. This introduces a new context from which you\r\n+  /// can obtain the [MYExpansionTileController]. With this approach you\r\n+  /// would have an outer widget that creates the [MYExpansionTile]\r\n+  /// populated by instances of your new inner widgets, and then in\r\n+  /// these inner widgets you would use [MYExpansionTileController.of].\r\n+  static MYExpansionTileController of(BuildContext context) {\r\n+    final _MYExpansionTileState? result =\r\n+        context.findAncestorStateOfType<_MYExpansionTileState>();\r\n+    if (result != null) {\r\n+      return result._tileController;\r\n+    }\r\n+    throw FlutterError.fromParts(<DiagnosticsNode>[\r\n+      ErrorSummary(\r\n+        'MYExpansionTileController.of() called with a context that does not contain a MYExpansionTile.',\r\n+      ),\r\n+      ErrorDescription(\r\n+        'No MYExpansionTile ancestor could be found starting from the context that was passed to MYExpansionTileController.of(). '\r\n+        'This usually happens when the context provided is from the same StatefulWidget as that '\r\n+        'whose build function actually creates the MYExpansionTile widget being sought.',\r\n+      ),\r\n+      ErrorHint(\r\n+        'There are several ways to avoid this problem. The simplest is to use a Builder to get a '\r\n+        'context that is \"under\" the MYExpansionTile. For an example of this, please see the '\r\n+        'documentation for MYExpansionTileController.of():\\n'\r\n+        '  https://api.flutter.dev/flutter/material/MYExpansionTile/of.html',\r\n+      ),\r\n+      ErrorHint(\r\n+        'A more efficient solution is to split your build function into several widgets. This '\r\n+        'introduces a new context from which you can obtain the MYExpansionTile. In this solution, '\r\n+        'you would have an outer widget that creates the MYExpansionTile populated by instances of '\r\n+        'your new inner widgets, and then in these inner widgets you would use MYExpansionTileController.of().\\n'\r\n+        'An other solution is assign a GlobalKey to the MYExpansionTile, '\r\n+        'then use the key.currentState property to obtain the MYExpansionTile rather than '\r\n+        'using the MYExpansionTileController.of() function.',\r\n+      ),\r\n+      context.describeElement('The context used was'),\r\n+    ]);\r\n+  }\r\n+\r\n+  /// Finds the [MYExpansionTile] from the closest instance of this class that\r\n+  /// encloses the given context and returns its [MYExpansionTileController].\r\n+  ///\r\n+  /// If no [MYExpansionTile] encloses the given context then return null.\r\n+  /// To throw an exception instead, use [of] instead of this function.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [of], a similar function to this one that throws if no [MYExpansionTile]\r\n+  ///    encloses the given context. Also includes some sample code in its\r\n+  ///    documentation.\r\n+  static MYExpansionTileController? maybeOf(BuildContext context) {\r\n+    return context\r\n+        .findAncestorStateOfType<_MYExpansionTileState>()\r\n+        ?._tileController;\r\n+  }\r\n+}\r\n+\r\n+/// A single-line [ListTile] with an expansion arrow icon that expands or collapses\r\n+/// the tile to reveal or hide the [children].\r\n+///\r\n+/// This widget is typically used with [ListView] to create an\r\n+/// \"expand / collapse\" list entry. When used with scrolling widgets like\r\n+/// [ListView], a unique [PageStorageKey] must be specified to enable the\r\n+/// [MYExpansionTile] to save and restore its expanded state when it is scrolled\r\n+/// in and out of view.\r\n+///\r\n+/// This class overrides the [ListTileThemeData.iconColor] and [ListTileThemeData.textColor]\r\n+/// theme properties for its [ListTile]. These colors animate between values when\r\n+/// the tile is expanded and collapsed: between [iconColor], [collapsedIconColor] and\r\n+/// between [textColor] and [collapsedTextColor].\r\n+///\r\n+/// The expansion arrow icon is shown on the right by default in left-to-right languages\r\n+/// (i.e. the trailing edge). This can be changed using [controlAffinity]. This maps\r\n+/// to the [leading] and [trailing] properties of [MYExpansionTile].\r\n+///\r\n+/// {@tool dartpad}\r\n+/// This example demonstrates how the [MYExpansionTile] icon's location and appearance\r\n+/// can be customized.\r\n+///\r\n+/// ** See code in examples/api/lib/material/expansion_tile/expansion_tile.0.dart **\r\n+/// {@end-tool}\r\n+///\r\n+/// {@tool dartpad}\r\n+/// This example demonstrates how an [MYExpansionTileController] can be used to\r\n+/// programatically expand or collapse an [MYExpansionTile].\r\n+///\r\n+/// ** See code in examples/api/lib/material/expansion_tile/expansion_tile.1.dart **\r\n+/// {@end-tool}\r\n+///\r\n+/// See also:\r\n+///\r\n+///  * [ListTile], useful for creating expansion tile [children] when the\r\n+///    expansion tile represents a sublist.\r\n+///  * The \"Expand and collapse\" section of\r\n+///    <https://material.io/components/lists#types>\r\n+class MYExpansionTile extends StatefulWidget {\r\n+  /// Creates a single-line [ListTile] with an expansion arrow icon that expands or collapses\r\n+  /// the tile to reveal or hide the [children]. The [initiallyExpanded] property must\r\n+  /// be non-null.\r\n+  const MYExpansionTile({\r\n+    super.key,\r\n+    this.leading,\r\n+    required this.title,\r\n+    this.subtitle,\r\n+    this.onExpansionChanged,\r\n+    this.children = const <Widget>[],\r\n+    this.trailing,\r\n+    this.initiallyExpanded = false,\r\n+    this.maintainState = false,\r\n+    this.tilePadding,\r\n+    this.expandedCrossAxisAlignment,\r\n+    this.expandedAlignment,\r\n+    this.childrenPadding,\r\n+    this.backgroundColor,\r\n+    this.collapsedBackgroundColor,\r\n+    this.textColor,\r\n+    this.collapsedTextColor,\r\n+    this.iconColor,\r\n+    this.collapsedIconColor,\r\n+    this.shape,\r\n+    this.collapsedShape,\r\n+    this.clipBehavior,\r\n+    this.controlAffinity,\r\n+    this.controller,\r\n+  }) : assert(\r\n+          expandedCrossAxisAlignment != CrossAxisAlignment.baseline,\r\n+          'CrossAxisAlignment.baseline is not supported since the expanded children '\r\n+          'are aligned in a column, not a row. Try to use another constant.',\r\n+        );\r\n+\r\n+  /// A widget to display before the title.\r\n+  ///\r\n+  /// Typically a [CircleAvatar] widget.\r\n+  ///\r\n+  /// Depending on the value of [controlAffinity], the [leading] widget\r\n+  /// may replace the rotating expansion arrow icon.\r\n+  final Widget? leading;\r\n+\r\n+  /// The primary content of the list item.\r\n+  ///\r\n+  /// Typically a [Text] widget.\r\n+  final Widget title;\r\n+\r\n+  /// Additional content displayed below the title.\r\n+  ///\r\n+  /// Typically a [Text] widget.\r\n+  final Widget? subtitle;\r\n+\r\n+  /// Called when the tile expands or collapses.\r\n+  ///\r\n+  /// When the tile starts expanding, this function is called with the value\r\n+  /// true. When the tile starts collapsing, this function is called with\r\n+  /// the value false.\r\n+  final ValueChanged<bool>? onExpansionChanged;\r\n+\r\n+  /// The widgets that are displayed when the tile expands.\r\n+  ///\r\n+  /// Typically [ListTile] widgets.\r\n+  final List<Widget> children;\r\n+\r\n+  /// The color to display behind the sublist when expanded.\r\n+  ///\r\n+  /// If this property is null then [MYExpansionTileThemeData.backgroundColor] is used. If that\r\n+  /// is also null then Colors.transparent is used.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n+  ///   [MYExpansionTileThemeData].\r\n+  final Color? backgroundColor;\r\n+\r\n+  /// When not null, defines the background color of tile when the sublist is collapsed.\r\n+  ///\r\n+  /// If this property is null then [MYExpansionTileThemeData.collapsedBackgroundColor] is used.\r\n+  /// If that is also null then Colors.transparent is used.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n+  ///   [MYExpansionTileThemeData].\r\n+  final Color? collapsedBackgroundColor;\r\n+\r\n+  /// A widget to display after the title.\r\n+  ///\r\n+  /// Depending on the value of [controlAffinity], the [trailing] widget\r\n+  /// may replace the rotating expansion arrow icon.\r\n+  final Widget? trailing;\r\n+\r\n+  /// Specifies if the list tile is initially expanded (true) or collapsed (false, the default).\r\n+  final bool initiallyExpanded;\r\n+\r\n+  /// Specifies whether the state of the children is maintained when the tile expands and collapses.\r\n+  ///\r\n+  /// When true, the children are kept in the tree while the tile is collapsed.\r\n+  /// When false (default), the children are removed from the tree when the tile is\r\n+  /// collapsed and recreated upon expansion.\r\n+  final bool maintainState;\r\n+\r\n+  /// Specifies padding for the [ListTile].\r\n+  ///\r\n+  /// Analogous to [ListTile.contentPadding], this property defines the insets for\r\n+  /// the [leading], [title], [subtitle] and [trailing] widgets. It does not inset\r\n+  /// the expanded [children] widgets.\r\n+  ///\r\n+  /// If this property is null then [MYExpansionTileThemeData.tilePadding] is used. If that\r\n+  /// is also null then the tile's padding is `EdgeInsets.symmetric(horizontal: 16.0)`.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n+  ///   [MYExpansionTileThemeData].\r\n+  final EdgeInsetsGeometry? tilePadding;\r\n+\r\n+  /// Specifies the alignment of [children], which are arranged in a column when\r\n+  /// the tile is expanded.\r\n+  ///\r\n+  /// The internals of the expanded tile make use of a [Column] widget for\r\n+  /// [children], and [Align] widget to align the column. The [expandedAlignment]\r\n+  /// parameter is passed directly into the [Align].\r\n+  ///\r\n+  /// Modifying this property controls the alignment of the column within the\r\n+  /// expanded tile, not the alignment of [children] widgets within the column.\r\n+  /// To align each child within [children], see [expandedCrossAxisAlignment].\r\n+  ///\r\n+  /// The width of the column is the width of the widest child widget in [children].\r\n+  ///\r\n+  /// If this property is null then [MYExpansionTileThemeData.expandedAlignment]is used. If that\r\n+  /// is also null then the value of [expandedAlignment] is [Alignment.center].\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n+  ///   [MYExpansionTileThemeData].\r\n+  final Alignment? expandedAlignment;\r\n+\r\n+  /// Specifies the alignment of each child within [children] when the tile is expanded.\r\n+  ///\r\n+  /// The internals of the expanded tile make use of a [Column] widget for\r\n+  /// [children], and the `crossAxisAlignment` parameter is passed directly into\r\n+  /// the [Column].\r\n+  ///\r\n+  /// Modifying this property controls the cross axis alignment of each child\r\n+  /// within its [Column]. The width of the [Column] that houses [children] will\r\n+  /// be the same as the widest child widget in [children]. The width of the\r\n+  /// [Column] might not be equal to the width of the expanded tile.\r\n+  ///\r\n+  /// To align the [Column] along the expanded tile, use the [expandedAlignment]\r\n+  /// property instead.\r\n+  ///\r\n+  /// When the value is null, the value of [expandedCrossAxisAlignment] is\r\n+  /// [CrossAxisAlignment.center].\r\n+  final CrossAxisAlignment? expandedCrossAxisAlignment;\r\n+\r\n+  /// Specifies padding for [children].\r\n+  ///\r\n+  /// If this property is null then [MYExpansionTileThemeData.childrenPadding] is used. If that\r\n+  /// is also null then the value of [childrenPadding] is [EdgeInsets.zero].\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n+  ///   [MYExpansionTileThemeData].\r\n+  final EdgeInsetsGeometry? childrenPadding;\r\n+\r\n+  /// The icon color of tile's expansion arrow icon when the sublist is expanded.\r\n+  ///\r\n+  /// Used to override to the [ListTileThemeData.iconColor].\r\n+  ///\r\n+  /// If this property is null then [MYExpansionTileThemeData.iconColor] is used. If that\r\n+  /// is also null then the value of [ColorScheme.primary] is used.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n+  ///   [MYExpansionTileThemeData].\r\n+  final Color? iconColor;\r\n+\r\n+  /// The icon color of tile's expansion arrow icon when the sublist is collapsed.\r\n+  ///\r\n+  /// Used to override to the [ListTileThemeData.iconColor].\r\n+  ///\r\n+  /// If this property is null then [MYExpansionTileThemeData.collapsedIconColor] is used. If that\r\n+  /// is also null and [ThemeData.useMaterial3] is true, [ColorScheme.onSurface] is used. Otherwise,\r\n+  /// defaults to [ThemeData.unselectedWidgetColor] color.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n+  ///   [MYExpansionTileThemeData].\r\n+  final Color? collapsedIconColor;\r\n+\r\n+  /// The color of the tile's titles when the sublist is expanded.\r\n+  ///\r\n+  /// Used to override to the [ListTileThemeData.textColor].\r\n+  ///\r\n+  /// If this property is null then [MYExpansionTileThemeData.textColor] is used. If that\r\n+  /// is also null then and [ThemeData.useMaterial3] is true, color of the [TextTheme.bodyLarge]\r\n+  /// will be used for the [title] and [subtitle]. Otherwise, defaults to [ColorScheme.primary] color.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n+  ///   [MYExpansionTileThemeData].\r\n+  final Color? textColor;\r\n+\r\n+  /// The color of the tile's titles when the sublist is collapsed.\r\n+  ///\r\n+  /// Used to override to the [ListTileThemeData.textColor].\r\n+  ///\r\n+  /// If this property is null then [MYExpansionTileThemeData.collapsedTextColor] is used.\r\n+  /// If that is also null and [ThemeData.useMaterial3] is true, color of the\r\n+  /// [TextTheme.bodyLarge] will be used for the [title] and [subtitle]. Otherwise,\r\n+  /// defaults to color of the [TextTheme.titleMedium].\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n+  ///   [MYExpansionTileThemeData].\r\n+  final Color? collapsedTextColor;\r\n+\r\n+  /// The tile's border shape when the sublist is expanded.\r\n+  ///\r\n+  /// If this property is null, the [MYExpansionTileThemeData.shape] is used. If that\r\n+  /// is also null, a [Border] with vertical sides default to [ThemeData.dividerColor] is used\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n+  ///   [MYExpansionTileThemeData].\r\n+  final ShapeBorder? shape;\r\n+\r\n+  /// The tile's border shape when the sublist is collapsed.\r\n+  ///\r\n+  /// If this property is null, the [MYExpansionTileThemeData.collapsedShape] is used. If that\r\n+  /// is also null, a [Border] with vertical sides default to Color [Colors.transparent] is used\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n+  ///   [MYExpansionTileThemeData].\r\n+  final ShapeBorder? collapsedShape;\r\n+\r\n+  /// {@macro flutter.material.Material.clipBehavior}\r\n+  ///\r\n+  /// If this property is null, the [MYExpansionTileThemeData.clipBehavior] is used. If that\r\n+  /// is also null, a [Clip.none] is used\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n+  ///   [MYExpansionTileThemeData].\r\n+  final Clip? clipBehavior;\r\n+\r\n+  /// Typically used to force the expansion arrow icon to the tile's leading or trailing edge.\r\n+  ///\r\n+  /// By default, the value of [controlAffinity] is [ListTileControlAffinity.platform],\r\n+  /// which means that the expansion arrow icon will appear on the tile's trailing edge.\r\n+  final ListTileControlAffinity? controlAffinity;\r\n+\r\n+  /// If provided, the controller can be used to expand and collapse tiles.\r\n+  ///\r\n+  /// In cases were control over the tile's state is needed from a callback triggered\r\n+  /// by a widget within the tile, [MYExpansionTileController.of] may be more convenient\r\n+  /// than supplying a controller.\r\n+  final MYExpansionTileController? controller;\r\n+\r\n+  @override\r\n+  State<MYExpansionTile> createState() => _MYExpansionTileState();\r\n+}\r\n+\r\n+class _MYExpansionTileState extends State<MYExpansionTile>\r\n+    with SingleTickerProviderStateMixin {\r\n+  static final Animatable<double> _easeOutTween =\r\n+      CurveTween(curve: Curves.easeOut);\r\n+  static final Animatable<double> _easeInTween =\r\n+      CurveTween(curve: Curves.easeIn);\r\n+  static final Animatable<double> _halfTween =\r\n+      Tween<double>(begin: 0.0, end: 0.5);\r\n+\r\n+  final ShapeBorderTween _borderTween = ShapeBorderTween();\r\n+  final ColorTween _headerColorTween = ColorTween();\r\n+  final ColorTween _iconColorTween = ColorTween();\r\n+  final ColorTween _backgroundColorTween = ColorTween();\r\n+\r\n+  late AnimationController _animationController;\r\n+  late Animation<double> _iconTurns;\r\n+  late Animation<double> _heightFactor;\r\n+  late Animation<ShapeBorder?> _border;\r\n+  late Animation<Color?> _headerColor;\r\n+  late Animation<Color?> _iconColor;\r\n+  late Animation<Color?> _backgroundColor;\r\n+\r\n+  bool _isExpanded = false;\r\n+  late MYExpansionTileController _tileController;\r\n+\r\n+  @override\r\n+  void initState() {\r\n+    super.initState();\r\n+    _animationController = AnimationController(duration: _kExpand, vsync: this);\r\n+    _heightFactor = _animationController.drive(_easeInTween);\r\n+    _iconTurns = _animationController.drive(_halfTween.chain(_easeInTween));\r\n+    _border = _animationController.drive(_borderTween.chain(_easeOutTween));\r\n+    _headerColor =\r\n+        _animationController.drive(_headerColorTween.chain(_easeInTween));\r\n+    _iconColor =\r\n+        _animationController.drive(_iconColorTween.chain(_easeInTween));\r\n+    _backgroundColor =\r\n+        _animationController.drive(_backgroundColorTween.chain(_easeOutTween));\r\n+\r\n+    _isExpanded = PageStorage.maybeOf(context)?.readState(context) as bool? ??\r\n+        widget.initiallyExpanded;\r\n+    if (_isExpanded) {\r\n+      _animationController.value = 1.0;\r\n+    }\r\n+\r\n+    assert(widget.controller?._state == null);\r\n+    _tileController = widget.controller ?? MYExpansionTileController();\r\n+    _tileController._state = this;\r\n+  }\r\n+\r\n+  @override\r\n+  void dispose() {\r\n+    _tileController._state = null;\r\n+    _animationController.dispose();\r\n+    super.dispose();\r\n+  }\r\n+\r\n+  void _toggleExpansion() {\r\n+    setState(() {\r\n+      _isExpanded = !_isExpanded;\r\n+      if (_isExpanded) {\r\n+        _animationController.forward();\r\n+      } else {\r\n+        _animationController.reverse().then<void>((void value) {\r\n+          if (!mounted) {\r\n+            return;\r\n+          }\r\n+          setState(() {\r\n+            // Rebuild without widget.children.\r\n+          });\r\n+        });\r\n+      }\r\n+      PageStorage.maybeOf(context)?.writeState(context, _isExpanded);\r\n+    });\r\n+    widget.onExpansionChanged?.call(_isExpanded);\r\n+  }\r\n+\r\n+  void _handleTap() {\r\n+    _toggleExpansion();\r\n+  }\r\n+\r\n+  // Platform or null affinity defaults to trailing.\r\n+  ListTileControlAffinity _effectiveAffinity(\r\n+      ListTileControlAffinity? affinity) {\r\n+    switch (affinity ?? ListTileControlAffinity.trailing) {\r\n+      case ListTileControlAffinity.leading:\r\n+        return ListTileControlAffinity.leading;\r\n+      case ListTileControlAffinity.trailing:\r\n+      case ListTileControlAffinity.platform:\r\n+        return ListTileControlAffinity.trailing;\r\n+    }\r\n+  }\r\n+\r\n+  Widget? _buildIcon(BuildContext context) {\r\n+    return RotationTransition(\r\n+      turns: _iconTurns,\r\n+      child: const Icon(Icons.expand_more),\r\n+    );\r\n+  }\r\n+\r\n+  Widget? _buildLeadingIcon(BuildContext context) {\r\n+    if (_effectiveAffinity(widget.controlAffinity) !=\r\n+        ListTileControlAffinity.leading) {\r\n+      return null;\r\n+    }\r\n+    return _buildIcon(context);\r\n+  }\r\n+\r\n+  Widget? _buildTrailingIcon(BuildContext context) {\r\n+    if (_effectiveAffinity(widget.controlAffinity) !=\r\n+        ListTileControlAffinity.trailing) {\r\n+      return null;\r\n+    }\r\n+    return _buildIcon(context);\r\n+  }\r\n+\r\n+  Widget _buildChildren(BuildContext context, Widget? child) {\r\n+    final ExpansionTileThemeData MYexpansionTileTheme =\r\n+        ExpansionTileThemeData.of(context);\r\n+    final ShapeBorder MYexpansionTileBorder = _border.value ??\r\n+        const Border(\r\n+          top: BorderSide(color: Colors.transparent),\r\n+          bottom: BorderSide(color: Colors.transparent),\r\n+        );\r\n+    final Clip clipBehavior =\r\n+        widget.clipBehavior ?? MYexpansionTileTheme.clipBehavior ?? Clip.none;\r\n+\r\n+    return Container(\r\n+      clipBehavior: clipBehavior,\r\n+      decoration: ShapeDecoration(\r\n+        color: _backgroundColor.value ??\r\n+            MYexpansionTileTheme.backgroundColor ??\r\n+            Colors.transparent,\r\n+        shape: MYexpansionTileBorder,\r\n+      ),\r\n+      child: Column(\r\n+        mainAxisSize: MainAxisSize.min,\r\n+        children: <Widget>[\r\n+          ListTileTheme.merge(\r\n+            iconColor: _iconColor.value ?? MYexpansionTileTheme.iconColor,\r\n+            textColor: _headerColor.value,\r\n+            child: ListTile(\r\n+              onTap: _handleTap,\r\n+              contentPadding:\r\n+                  widget.tilePadding ?? MYexpansionTileTheme.tilePadding,\r\n+              leading: widget.leading ?? _buildLeadingIcon(context),\r\n+              title: widget.title,\r\n+              subtitle: widget.subtitle,\r\n+              trailing: widget.trailing ?? _buildTrailingIcon(context),\r\n+            ),\r\n+          ),\r\n+          ClipRect(\r\n+            child: Align(\r\n+              alignment: widget.expandedAlignment ??\r\n+                  MYexpansionTileTheme.expandedAlignment ??\r\n+                  Alignment.center,\r\n+              heightFactor: _heightFactor.value,\r\n+              child: child,\r\n+            ),\r\n+          ),\r\n+        ],\r\n+      ),\r\n+    );\r\n+  }\r\n+\r\n+  @override\r\n+  void didChangeDependencies() {\r\n+    final ThemeData theme = Theme.of(context);\r\n+    final MYExpansionTileThemeData MYexpansionTileTheme =\r\n+        MYExpansionTileTheme.of(context);\r\n+    final MYExpansionTileThemeData defaults = theme.useMaterial3\r\n+        ? _MYExpansionTileDefaultsM3(context)\r\n+        : _MYExpansionTileDefaultsM2(context);\r\n+    _borderTween\r\n+      ..begin = widget.collapsedShape ??\r\n+          MYexpansionTileTheme.collapsedShape ??\r\n+          const Border(\r\n+            top: BorderSide(color: Colors.transparent),\r\n+            bottom: BorderSide(color: Colors.transparent),\r\n+          )\r\n+      ..end = widget.shape ??\r\n+          MYexpansionTileTheme.collapsedShape ??\r\n+          Border(\r\n+            top: BorderSide(color: theme.dividerColor),\r\n+            bottom: BorderSide(color: theme.dividerColor),\r\n+          );\r\n+    _headerColorTween\r\n+      ..begin = widget.collapsedTextColor ??\r\n+          MYexpansionTileTheme.collapsedTextColor ??\r\n+          defaults.collapsedTextColor\r\n+      ..end = widget.textColor ??\r\n+          MYexpansionTileTheme.textColor ??\r\n+          defaults.textColor;\r\n+    _iconColorTween\r\n+      ..begin = widget.collapsedIconColor ??\r\n+          MYexpansionTileTheme.collapsedIconColor ??\r\n+          defaults.collapsedIconColor\r\n+      ..end = widget.iconColor ??\r\n+          MYexpansionTileTheme.iconColor ??\r\n+          defaults.iconColor;\r\n+    _backgroundColorTween\r\n+      ..begin = widget.collapsedBackgroundColor ??\r\n+          MYexpansionTileTheme.collapsedBackgroundColor\r\n+      ..end = widget.backgroundColor ?? MYexpansionTileTheme.backgroundColor;\r\n+    super.didChangeDependencies();\r\n+  }\r\n+\r\n+  @override\r\n+  Widget build(BuildContext context) {\r\n+    final MYExpansionTileThemeData MYexpansionTileTheme =\r\n+        MYExpansionTileTheme.of(context);\r\n+    final bool closed = !_isExpanded && _animationController.isDismissed;\r\n+    final bool shouldRemoveChildren = closed && !widget.maintainState;\r\n+\r\n+    final Widget result = Offstage(\r\n+      offstage: closed,\r\n+      child: TickerMode(\r\n+        enabled: !closed,\r\n+        child: Padding(\r\n+          padding: widget.childrenPadding ??\r\n+              MYexpansionTileTheme.childrenPadding ??\r\n+              EdgeInsets.zero,\r\n+          child: Column(\r\n+            crossAxisAlignment:\r\n+                widget.expandedCrossAxisAlignment ?? CrossAxisAlignment.center,\r\n+            children: widget.children,\r\n+          ),\r\n+        ),\r\n+      ),\r\n+    );\r\n+\r\n+    return AnimatedBuilder(\r\n+      animation: _animationController.view,\r\n+      builder: _buildChildren,\r\n+      child: shouldRemoveChildren ? null : result,\r\n+    );\r\n+  }\r\n+}\r\n+\r\n+class _MYExpansionTileDefaultsM2 extends MYExpansionTileThemeData {\r\n+  _MYExpansionTileDefaultsM2(this.context);\r\n+\r\n+  final BuildContext context;\r\n+  late final ThemeData _theme = Theme.of(context);\r\n+  late final ColorScheme _colorScheme = _theme.colorScheme;\r\n+\r\n+  @override\r\n+  Color? get textColor => _colorScheme.primary;\r\n+\r\n+  @override\r\n+  Color? get iconColor => _colorScheme.primary;\r\n+\r\n+  @override\r\n+  Color? get collapsedTextColor => _theme.textTheme.titleMedium!.color;\r\n+\r\n+  @override\r\n+  Color? get collapsedIconColor => _theme.unselectedWidgetColor;\r\n+}\r\n+\r\n+// BEGIN GENERATED TOKEN PROPERTIES - MYExpansionTile\r\n+\r\n+// Do not edit by hand. The code between the \"BEGIN GENERATED\" and\r\n+// \"END GENERATED\" comments are generated from data in the Material\r\n+// Design token database by the script:\r\n+//   dev/tools/gen_defaults/bin/gen_defaults.dart.\r\n+\r\n+// Token database version: v0_162\r\n+\r\n+class _MYExpansionTileDefaultsM3 extends MYExpansionTileThemeData {\r\n+  _MYExpansionTileDefaultsM3(this.context);\r\n+\r\n+  final BuildContext context;\r\n+  late final ThemeData _theme = Theme.of(context);\r\n+  late final ColorScheme _colors = _theme.colorScheme;\r\n+\r\n+  @override\r\n+  Color? get textColor => _colors.onSurface;\r\n+\r\n+  @override\r\n+  Color? get iconColor => _colors.primary;\r\n+\r\n+  @override\r\n+  Color? get collapsedTextColor => _colors.onSurface;\r\n+\r\n+  @override\r\n+  Color? get collapsedIconColor => _colors.onSurfaceVariant;\r\n+}\r\n+\r\n+// END GENERATED TOKEN PROPERTIES - MYExpansionTile\r\n"
                },
                {
                    "date": 1694523193599,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,787 +0,0 @@\n-// Copyright 2014 The Flutter Authors. All rights reserved.\r\n-// Use of this source code is governed by a BSD-style license that can be\r\n-// found in the LICENSE file.\r\n-\r\n-import 'package:flutter/material.dart';\r\n-import 'package:flutter/widgets.dart';\r\n-\r\n-import 'color_scheme.dart';\r\n-import 'colors.dart';\r\n-import 'expansion_tile_theme.dart';\r\n-import 'icons.dart';\r\n-import 'list_tile.dart';\r\n-import 'list_tile_theme.dart';\r\n-import 'material.dart';\r\n-import 'theme.dart';\r\n-\r\n-const Duration _kExpand = Duration(milliseconds: 200);\r\n-\r\n-/// Enables control over a single [MYExpansionTile]'s expanded/collapsed state.\r\n-///\r\n-/// It can be useful to expand or collapse an [MYExpansionTile]\r\n-/// programatically, for example to reconfigure an existing expansion\r\n-/// tile based on a system event. To do so, create an [MYExpansionTile]\r\n-/// with an [MYExpansionTileController] that's owned by a stateful widget\r\n-/// or look up the tile's automatically created [MYExpansionTileController]\r\n-/// with [MYExpansionTileController.of]\r\n-///\r\n-/// The controller's [expand] and [collapse] methods cause the\r\n-/// the [MYExpansionTile] to rebuild, so they may not be called from\r\n-/// a build method.\r\n-class MYExpansionTileController {\r\n-  /// Create a controller to be used with [MYExpansionTile.controller].\r\n-  MYExpansionTileController();\r\n-\r\n-  _MYExpansionTileState? _state;\r\n-\r\n-  /// Whether the [MYExpansionTile] built with this controller is in expanded state.\r\n-  ///\r\n-  /// This property doesn't take the animation into account. It reports `true`\r\n-  /// even if the expansion animation is not completed.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  ///  * [expand], which expands the [MYExpansionTile].\r\n-  ///  * [collapse], which collapses the [MYExpansionTile].\r\n-  ///  * [MYExpansionTile.controller] to create an MYExpansionTile with a controller.\r\n-  bool get isExpanded {\r\n-    assert(_state != null);\r\n-    return _state!._isExpanded;\r\n-  }\r\n-\r\n-  /// Expands the [MYExpansionTile] that was built with this controller;\r\n-  ///\r\n-  /// Normally the tile is expanded automatically when the user taps on the header.\r\n-  /// It is sometimes useful to trigger the expansion programmatically due\r\n-  /// to external changes.\r\n-  ///\r\n-  /// If the tile is already in the expanded state (see [isExpanded]), calling\r\n-  /// this method has no effect.\r\n-  ///\r\n-  /// Calling this method may cause the [MYExpansionTile] to rebuild, so it may\r\n-  /// not be called from a build method.\r\n-  ///\r\n-  /// Calling this method will trigger an [MYExpansionTile.onExpansionChanged] callback.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  ///  * [collapse], which collapses the tile.\r\n-  ///  * [isExpanded] to check whether the tile is expanded.\r\n-  ///  * [MYExpansionTile.controller] to create an MYExpansionTile with a controller.\r\n-  void expand() {\r\n-    assert(_state != null);\r\n-    if (!isExpanded) {\r\n-      _state!._toggleExpansion();\r\n-    }\r\n-  }\r\n-\r\n-  /// Collapses the [MYExpansionTile] that was built with this controller.\r\n-  ///\r\n-  /// Normally the tile is collapsed automatically when the user taps on the header.\r\n-  /// It can be useful sometimes to trigger the collapse programmatically due\r\n-  /// to some external changes.\r\n-  ///\r\n-  /// If the tile is already in the collapsed state (see [isExpanded]), calling\r\n-  /// this method has no effect.\r\n-  ///\r\n-  /// Calling this method may cause the [MYExpansionTile] to rebuild, so it may\r\n-  /// not be called from a build method.\r\n-  ///\r\n-  /// Calling this method will trigger an [MYExpansionTile.onExpansionChanged] callback.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  ///  * [expand], which expands the tile.\r\n-  ///  * [isExpanded] to check whether the tile is expanded.\r\n-  ///  * [MYExpansionTile.controller] to create an MYExpansionTile with a controller.\r\n-  void collapse() {\r\n-    assert(_state != null);\r\n-    if (isExpanded) {\r\n-      _state!._toggleExpansion();\r\n-    }\r\n-  }\r\n-\r\n-  /// Finds the [MYExpansionTileController] for the closest [MYExpansionTile] instance\r\n-  /// that encloses the given context.\r\n-  ///\r\n-  /// If no [MYExpansionTile] encloses the given context, calling this\r\n-  /// method will cause an assert in debug mode, and throw an\r\n-  /// exception in release mode.\r\n-  ///\r\n-  /// To return null if there is no [MYExpansionTile] use [maybeOf] instead.\r\n-  ///\r\n-  /// {@tool dartpad}\r\n-  /// Typical usage of the [MYExpansionTileController.of] function is to call it from within the\r\n-  /// `build` method of a descendant of an [MYExpansionTile].\r\n-  ///\r\n-  /// When the [MYExpansionTile] is actually created in the same `build`\r\n-  /// function as the callback that refers to the controller, then the\r\n-  /// `context` argument to the `build` function can't be used to find\r\n-  /// the [MYExpansionTileController] (since it's \"above\" the widget\r\n-  /// being returned in the widget tree). In cases like that you can\r\n-  /// add a [Builder] widget, which provides a new scope with a\r\n-  /// [BuildContext] that is \"under\" the [MYExpansionTile]:\r\n-  ///\r\n-  /// ** See code in examples/api/lib/material/expansion_tile/expansion_tile.1.dart **\r\n-  /// {@end-tool}\r\n-  ///\r\n-  /// A more efficient solution is to split your build function into\r\n-  /// several widgets. This introduces a new context from which you\r\n-  /// can obtain the [MYExpansionTileController]. With this approach you\r\n-  /// would have an outer widget that creates the [MYExpansionTile]\r\n-  /// populated by instances of your new inner widgets, and then in\r\n-  /// these inner widgets you would use [MYExpansionTileController.of].\r\n-  static MYExpansionTileController of(BuildContext context) {\r\n-    final _MYExpansionTileState? result =\r\n-        context.findAncestorStateOfType<_MYExpansionTileState>();\r\n-    if (result != null) {\r\n-      return result._tileController;\r\n-    }\r\n-    throw FlutterError.fromParts(<DiagnosticsNode>[\r\n-      ErrorSummary(\r\n-        'MYExpansionTileController.of() called with a context that does not contain a MYExpansionTile.',\r\n-      ),\r\n-      ErrorDescription(\r\n-        'No MYExpansionTile ancestor could be found starting from the context that was passed to MYExpansionTileController.of(). '\r\n-        'This usually happens when the context provided is from the same StatefulWidget as that '\r\n-        'whose build function actually creates the MYExpansionTile widget being sought.',\r\n-      ),\r\n-      ErrorHint(\r\n-        'There are several ways to avoid this problem. The simplest is to use a Builder to get a '\r\n-        'context that is \"under\" the MYExpansionTile. For an example of this, please see the '\r\n-        'documentation for MYExpansionTileController.of():\\n'\r\n-        '  https://api.flutter.dev/flutter/material/MYExpansionTile/of.html',\r\n-      ),\r\n-      ErrorHint(\r\n-        'A more efficient solution is to split your build function into several widgets. This '\r\n-        'introduces a new context from which you can obtain the MYExpansionTile. In this solution, '\r\n-        'you would have an outer widget that creates the MYExpansionTile populated by instances of '\r\n-        'your new inner widgets, and then in these inner widgets you would use MYExpansionTileController.of().\\n'\r\n-        'An other solution is assign a GlobalKey to the MYExpansionTile, '\r\n-        'then use the key.currentState property to obtain the MYExpansionTile rather than '\r\n-        'using the MYExpansionTileController.of() function.',\r\n-      ),\r\n-      context.describeElement('The context used was'),\r\n-    ]);\r\n-  }\r\n-\r\n-  /// Finds the [MYExpansionTile] from the closest instance of this class that\r\n-  /// encloses the given context and returns its [MYExpansionTileController].\r\n-  ///\r\n-  /// If no [MYExpansionTile] encloses the given context then return null.\r\n-  /// To throw an exception instead, use [of] instead of this function.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  ///  * [of], a similar function to this one that throws if no [MYExpansionTile]\r\n-  ///    encloses the given context. Also includes some sample code in its\r\n-  ///    documentation.\r\n-  static MYExpansionTileController? maybeOf(BuildContext context) {\r\n-    return context\r\n-        .findAncestorStateOfType<_MYExpansionTileState>()\r\n-        ?._tileController;\r\n-  }\r\n-}\r\n-\r\n-/// A single-line [ListTile] with an expansion arrow icon that expands or collapses\r\n-/// the tile to reveal or hide the [children].\r\n-///\r\n-/// This widget is typically used with [ListView] to create an\r\n-/// \"expand / collapse\" list entry. When used with scrolling widgets like\r\n-/// [ListView], a unique [PageStorageKey] must be specified to enable the\r\n-/// [MYExpansionTile] to save and restore its expanded state when it is scrolled\r\n-/// in and out of view.\r\n-///\r\n-/// This class overrides the [ListTileThemeData.iconColor] and [ListTileThemeData.textColor]\r\n-/// theme properties for its [ListTile]. These colors animate between values when\r\n-/// the tile is expanded and collapsed: between [iconColor], [collapsedIconColor] and\r\n-/// between [textColor] and [collapsedTextColor].\r\n-///\r\n-/// The expansion arrow icon is shown on the right by default in left-to-right languages\r\n-/// (i.e. the trailing edge). This can be changed using [controlAffinity]. This maps\r\n-/// to the [leading] and [trailing] properties of [MYExpansionTile].\r\n-///\r\n-/// {@tool dartpad}\r\n-/// This example demonstrates how the [MYExpansionTile] icon's location and appearance\r\n-/// can be customized.\r\n-///\r\n-/// ** See code in examples/api/lib/material/expansion_tile/expansion_tile.0.dart **\r\n-/// {@end-tool}\r\n-///\r\n-/// {@tool dartpad}\r\n-/// This example demonstrates how an [MYExpansionTileController] can be used to\r\n-/// programatically expand or collapse an [MYExpansionTile].\r\n-///\r\n-/// ** See code in examples/api/lib/material/expansion_tile/expansion_tile.1.dart **\r\n-/// {@end-tool}\r\n-///\r\n-/// See also:\r\n-///\r\n-///  * [ListTile], useful for creating expansion tile [children] when the\r\n-///    expansion tile represents a sublist.\r\n-///  * The \"Expand and collapse\" section of\r\n-///    <https://material.io/components/lists#types>\r\n-class MYExpansionTile extends StatefulWidget {\r\n-  /// Creates a single-line [ListTile] with an expansion arrow icon that expands or collapses\r\n-  /// the tile to reveal or hide the [children]. The [initiallyExpanded] property must\r\n-  /// be non-null.\r\n-  const MYExpansionTile({\r\n-    super.key,\r\n-    this.leading,\r\n-    required this.title,\r\n-    this.subtitle,\r\n-    this.onExpansionChanged,\r\n-    this.children = const <Widget>[],\r\n-    this.trailing,\r\n-    this.initiallyExpanded = false,\r\n-    this.maintainState = false,\r\n-    this.tilePadding,\r\n-    this.expandedCrossAxisAlignment,\r\n-    this.expandedAlignment,\r\n-    this.childrenPadding,\r\n-    this.backgroundColor,\r\n-    this.collapsedBackgroundColor,\r\n-    this.textColor,\r\n-    this.collapsedTextColor,\r\n-    this.iconColor,\r\n-    this.collapsedIconColor,\r\n-    this.shape,\r\n-    this.collapsedShape,\r\n-    this.clipBehavior,\r\n-    this.controlAffinity,\r\n-    this.controller,\r\n-  }) : assert(\r\n-          expandedCrossAxisAlignment != CrossAxisAlignment.baseline,\r\n-          'CrossAxisAlignment.baseline is not supported since the expanded children '\r\n-          'are aligned in a column, not a row. Try to use another constant.',\r\n-        );\r\n-\r\n-  /// A widget to display before the title.\r\n-  ///\r\n-  /// Typically a [CircleAvatar] widget.\r\n-  ///\r\n-  /// Depending on the value of [controlAffinity], the [leading] widget\r\n-  /// may replace the rotating expansion arrow icon.\r\n-  final Widget? leading;\r\n-\r\n-  /// The primary content of the list item.\r\n-  ///\r\n-  /// Typically a [Text] widget.\r\n-  final Widget title;\r\n-\r\n-  /// Additional content displayed below the title.\r\n-  ///\r\n-  /// Typically a [Text] widget.\r\n-  final Widget? subtitle;\r\n-\r\n-  /// Called when the tile expands or collapses.\r\n-  ///\r\n-  /// When the tile starts expanding, this function is called with the value\r\n-  /// true. When the tile starts collapsing, this function is called with\r\n-  /// the value false.\r\n-  final ValueChanged<bool>? onExpansionChanged;\r\n-\r\n-  /// The widgets that are displayed when the tile expands.\r\n-  ///\r\n-  /// Typically [ListTile] widgets.\r\n-  final List<Widget> children;\r\n-\r\n-  /// The color to display behind the sublist when expanded.\r\n-  ///\r\n-  /// If this property is null then [MYExpansionTileThemeData.backgroundColor] is used. If that\r\n-  /// is also null then Colors.transparent is used.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n-  ///   [MYExpansionTileThemeData].\r\n-  final Color? backgroundColor;\r\n-\r\n-  /// When not null, defines the background color of tile when the sublist is collapsed.\r\n-  ///\r\n-  /// If this property is null then [MYExpansionTileThemeData.collapsedBackgroundColor] is used.\r\n-  /// If that is also null then Colors.transparent is used.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n-  ///   [MYExpansionTileThemeData].\r\n-  final Color? collapsedBackgroundColor;\r\n-\r\n-  /// A widget to display after the title.\r\n-  ///\r\n-  /// Depending on the value of [controlAffinity], the [trailing] widget\r\n-  /// may replace the rotating expansion arrow icon.\r\n-  final Widget? trailing;\r\n-\r\n-  /// Specifies if the list tile is initially expanded (true) or collapsed (false, the default).\r\n-  final bool initiallyExpanded;\r\n-\r\n-  /// Specifies whether the state of the children is maintained when the tile expands and collapses.\r\n-  ///\r\n-  /// When true, the children are kept in the tree while the tile is collapsed.\r\n-  /// When false (default), the children are removed from the tree when the tile is\r\n-  /// collapsed and recreated upon expansion.\r\n-  final bool maintainState;\r\n-\r\n-  /// Specifies padding for the [ListTile].\r\n-  ///\r\n-  /// Analogous to [ListTile.contentPadding], this property defines the insets for\r\n-  /// the [leading], [title], [subtitle] and [trailing] widgets. It does not inset\r\n-  /// the expanded [children] widgets.\r\n-  ///\r\n-  /// If this property is null then [MYExpansionTileThemeData.tilePadding] is used. If that\r\n-  /// is also null then the tile's padding is `EdgeInsets.symmetric(horizontal: 16.0)`.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n-  ///   [MYExpansionTileThemeData].\r\n-  final EdgeInsetsGeometry? tilePadding;\r\n-\r\n-  /// Specifies the alignment of [children], which are arranged in a column when\r\n-  /// the tile is expanded.\r\n-  ///\r\n-  /// The internals of the expanded tile make use of a [Column] widget for\r\n-  /// [children], and [Align] widget to align the column. The [expandedAlignment]\r\n-  /// parameter is passed directly into the [Align].\r\n-  ///\r\n-  /// Modifying this property controls the alignment of the column within the\r\n-  /// expanded tile, not the alignment of [children] widgets within the column.\r\n-  /// To align each child within [children], see [expandedCrossAxisAlignment].\r\n-  ///\r\n-  /// The width of the column is the width of the widest child widget in [children].\r\n-  ///\r\n-  /// If this property is null then [MYExpansionTileThemeData.expandedAlignment]is used. If that\r\n-  /// is also null then the value of [expandedAlignment] is [Alignment.center].\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n-  ///   [MYExpansionTileThemeData].\r\n-  final Alignment? expandedAlignment;\r\n-\r\n-  /// Specifies the alignment of each child within [children] when the tile is expanded.\r\n-  ///\r\n-  /// The internals of the expanded tile make use of a [Column] widget for\r\n-  /// [children], and the `crossAxisAlignment` parameter is passed directly into\r\n-  /// the [Column].\r\n-  ///\r\n-  /// Modifying this property controls the cross axis alignment of each child\r\n-  /// within its [Column]. The width of the [Column] that houses [children] will\r\n-  /// be the same as the widest child widget in [children]. The width of the\r\n-  /// [Column] might not be equal to the width of the expanded tile.\r\n-  ///\r\n-  /// To align the [Column] along the expanded tile, use the [expandedAlignment]\r\n-  /// property instead.\r\n-  ///\r\n-  /// When the value is null, the value of [expandedCrossAxisAlignment] is\r\n-  /// [CrossAxisAlignment.center].\r\n-  final CrossAxisAlignment? expandedCrossAxisAlignment;\r\n-\r\n-  /// Specifies padding for [children].\r\n-  ///\r\n-  /// If this property is null then [MYExpansionTileThemeData.childrenPadding] is used. If that\r\n-  /// is also null then the value of [childrenPadding] is [EdgeInsets.zero].\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n-  ///   [MYExpansionTileThemeData].\r\n-  final EdgeInsetsGeometry? childrenPadding;\r\n-\r\n-  /// The icon color of tile's expansion arrow icon when the sublist is expanded.\r\n-  ///\r\n-  /// Used to override to the [ListTileThemeData.iconColor].\r\n-  ///\r\n-  /// If this property is null then [MYExpansionTileThemeData.iconColor] is used. If that\r\n-  /// is also null then the value of [ColorScheme.primary] is used.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n-  ///   [MYExpansionTileThemeData].\r\n-  final Color? iconColor;\r\n-\r\n-  /// The icon color of tile's expansion arrow icon when the sublist is collapsed.\r\n-  ///\r\n-  /// Used to override to the [ListTileThemeData.iconColor].\r\n-  ///\r\n-  /// If this property is null then [MYExpansionTileThemeData.collapsedIconColor] is used. If that\r\n-  /// is also null and [ThemeData.useMaterial3] is true, [ColorScheme.onSurface] is used. Otherwise,\r\n-  /// defaults to [ThemeData.unselectedWidgetColor] color.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n-  ///   [MYExpansionTileThemeData].\r\n-  final Color? collapsedIconColor;\r\n-\r\n-  /// The color of the tile's titles when the sublist is expanded.\r\n-  ///\r\n-  /// Used to override to the [ListTileThemeData.textColor].\r\n-  ///\r\n-  /// If this property is null then [MYExpansionTileThemeData.textColor] is used. If that\r\n-  /// is also null then and [ThemeData.useMaterial3] is true, color of the [TextTheme.bodyLarge]\r\n-  /// will be used for the [title] and [subtitle]. Otherwise, defaults to [ColorScheme.primary] color.\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n-  ///   [MYExpansionTileThemeData].\r\n-  final Color? textColor;\r\n-\r\n-  /// The color of the tile's titles when the sublist is collapsed.\r\n-  ///\r\n-  /// Used to override to the [ListTileThemeData.textColor].\r\n-  ///\r\n-  /// If this property is null then [MYExpansionTileThemeData.collapsedTextColor] is used.\r\n-  /// If that is also null and [ThemeData.useMaterial3] is true, color of the\r\n-  /// [TextTheme.bodyLarge] will be used for the [title] and [subtitle]. Otherwise,\r\n-  /// defaults to color of the [TextTheme.titleMedium].\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n-  ///   [MYExpansionTileThemeData].\r\n-  final Color? collapsedTextColor;\r\n-\r\n-  /// The tile's border shape when the sublist is expanded.\r\n-  ///\r\n-  /// If this property is null, the [MYExpansionTileThemeData.shape] is used. If that\r\n-  /// is also null, a [Border] with vertical sides default to [ThemeData.dividerColor] is used\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n-  ///   [MYExpansionTileThemeData].\r\n-  final ShapeBorder? shape;\r\n-\r\n-  /// The tile's border shape when the sublist is collapsed.\r\n-  ///\r\n-  /// If this property is null, the [MYExpansionTileThemeData.collapsedShape] is used. If that\r\n-  /// is also null, a [Border] with vertical sides default to Color [Colors.transparent] is used\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n-  ///   [MYExpansionTileThemeData].\r\n-  final ShapeBorder? collapsedShape;\r\n-\r\n-  /// {@macro flutter.material.Material.clipBehavior}\r\n-  ///\r\n-  /// If this property is null, the [MYExpansionTileThemeData.clipBehavior] is used. If that\r\n-  /// is also null, a [Clip.none] is used\r\n-  ///\r\n-  /// See also:\r\n-  ///\r\n-  /// * [MYExpansionTileTheme.of], which returns the nearest [MYExpansionTileTheme]'s\r\n-  ///   [MYExpansionTileThemeData].\r\n-  final Clip? clipBehavior;\r\n-\r\n-  /// Typically used to force the expansion arrow icon to the tile's leading or trailing edge.\r\n-  ///\r\n-  /// By default, the value of [controlAffinity] is [ListTileControlAffinity.platform],\r\n-  /// which means that the expansion arrow icon will appear on the tile's trailing edge.\r\n-  final ListTileControlAffinity? controlAffinity;\r\n-\r\n-  /// If provided, the controller can be used to expand and collapse tiles.\r\n-  ///\r\n-  /// In cases were control over the tile's state is needed from a callback triggered\r\n-  /// by a widget within the tile, [MYExpansionTileController.of] may be more convenient\r\n-  /// than supplying a controller.\r\n-  final MYExpansionTileController? controller;\r\n-\r\n-  @override\r\n-  State<MYExpansionTile> createState() => _MYExpansionTileState();\r\n-}\r\n-\r\n-class _MYExpansionTileState extends State<MYExpansionTile>\r\n-    with SingleTickerProviderStateMixin {\r\n-  static final Animatable<double> _easeOutTween =\r\n-      CurveTween(curve: Curves.easeOut);\r\n-  static final Animatable<double> _easeInTween =\r\n-      CurveTween(curve: Curves.easeIn);\r\n-  static final Animatable<double> _halfTween =\r\n-      Tween<double>(begin: 0.0, end: 0.5);\r\n-\r\n-  final ShapeBorderTween _borderTween = ShapeBorderTween();\r\n-  final ColorTween _headerColorTween = ColorTween();\r\n-  final ColorTween _iconColorTween = ColorTween();\r\n-  final ColorTween _backgroundColorTween = ColorTween();\r\n-\r\n-  late AnimationController _animationController;\r\n-  late Animation<double> _iconTurns;\r\n-  late Animation<double> _heightFactor;\r\n-  late Animation<ShapeBorder?> _border;\r\n-  late Animation<Color?> _headerColor;\r\n-  late Animation<Color?> _iconColor;\r\n-  late Animation<Color?> _backgroundColor;\r\n-\r\n-  bool _isExpanded = false;\r\n-  late MYExpansionTileController _tileController;\r\n-\r\n-  @override\r\n-  void initState() {\r\n-    super.initState();\r\n-    _animationController = AnimationController(duration: _kExpand, vsync: this);\r\n-    _heightFactor = _animationController.drive(_easeInTween);\r\n-    _iconTurns = _animationController.drive(_halfTween.chain(_easeInTween));\r\n-    _border = _animationController.drive(_borderTween.chain(_easeOutTween));\r\n-    _headerColor =\r\n-        _animationController.drive(_headerColorTween.chain(_easeInTween));\r\n-    _iconColor =\r\n-        _animationController.drive(_iconColorTween.chain(_easeInTween));\r\n-    _backgroundColor =\r\n-        _animationController.drive(_backgroundColorTween.chain(_easeOutTween));\r\n-\r\n-    _isExpanded = PageStorage.maybeOf(context)?.readState(context) as bool? ??\r\n-        widget.initiallyExpanded;\r\n-    if (_isExpanded) {\r\n-      _animationController.value = 1.0;\r\n-    }\r\n-\r\n-    assert(widget.controller?._state == null);\r\n-    _tileController = widget.controller ?? MYExpansionTileController();\r\n-    _tileController._state = this;\r\n-  }\r\n-\r\n-  @override\r\n-  void dispose() {\r\n-    _tileController._state = null;\r\n-    _animationController.dispose();\r\n-    super.dispose();\r\n-  }\r\n-\r\n-  void _toggleExpansion() {\r\n-    setState(() {\r\n-      _isExpanded = !_isExpanded;\r\n-      if (_isExpanded) {\r\n-        _animationController.forward();\r\n-      } else {\r\n-        _animationController.reverse().then<void>((void value) {\r\n-          if (!mounted) {\r\n-            return;\r\n-          }\r\n-          setState(() {\r\n-            // Rebuild without widget.children.\r\n-          });\r\n-        });\r\n-      }\r\n-      PageStorage.maybeOf(context)?.writeState(context, _isExpanded);\r\n-    });\r\n-    widget.onExpansionChanged?.call(_isExpanded);\r\n-  }\r\n-\r\n-  void _handleTap() {\r\n-    _toggleExpansion();\r\n-  }\r\n-\r\n-  // Platform or null affinity defaults to trailing.\r\n-  ListTileControlAffinity _effectiveAffinity(\r\n-      ListTileControlAffinity? affinity) {\r\n-    switch (affinity ?? ListTileControlAffinity.trailing) {\r\n-      case ListTileControlAffinity.leading:\r\n-        return ListTileControlAffinity.leading;\r\n-      case ListTileControlAffinity.trailing:\r\n-      case ListTileControlAffinity.platform:\r\n-        return ListTileControlAffinity.trailing;\r\n-    }\r\n-  }\r\n-\r\n-  Widget? _buildIcon(BuildContext context) {\r\n-    return RotationTransition(\r\n-      turns: _iconTurns,\r\n-      child: const Icon(Icons.expand_more),\r\n-    );\r\n-  }\r\n-\r\n-  Widget? _buildLeadingIcon(BuildContext context) {\r\n-    if (_effectiveAffinity(widget.controlAffinity) !=\r\n-        ListTileControlAffinity.leading) {\r\n-      return null;\r\n-    }\r\n-    return _buildIcon(context);\r\n-  }\r\n-\r\n-  Widget? _buildTrailingIcon(BuildContext context) {\r\n-    if (_effectiveAffinity(widget.controlAffinity) !=\r\n-        ListTileControlAffinity.trailing) {\r\n-      return null;\r\n-    }\r\n-    return _buildIcon(context);\r\n-  }\r\n-\r\n-  Widget _buildChildren(BuildContext context, Widget? child) {\r\n-    final ExpansionTileThemeData MYexpansionTileTheme =\r\n-        ExpansionTileThemeData.of(context);\r\n-    final ShapeBorder MYexpansionTileBorder = _border.value ??\r\n-        const Border(\r\n-          top: BorderSide(color: Colors.transparent),\r\n-          bottom: BorderSide(color: Colors.transparent),\r\n-        );\r\n-    final Clip clipBehavior =\r\n-        widget.clipBehavior ?? MYexpansionTileTheme.clipBehavior ?? Clip.none;\r\n-\r\n-    return Container(\r\n-      clipBehavior: clipBehavior,\r\n-      decoration: ShapeDecoration(\r\n-        color: _backgroundColor.value ??\r\n-            MYexpansionTileTheme.backgroundColor ??\r\n-            Colors.transparent,\r\n-        shape: MYexpansionTileBorder,\r\n-      ),\r\n-      child: Column(\r\n-        mainAxisSize: MainAxisSize.min,\r\n-        children: <Widget>[\r\n-          ListTileTheme.merge(\r\n-            iconColor: _iconColor.value ?? MYexpansionTileTheme.iconColor,\r\n-            textColor: _headerColor.value,\r\n-            child: ListTile(\r\n-              onTap: _handleTap,\r\n-              contentPadding:\r\n-                  widget.tilePadding ?? MYexpansionTileTheme.tilePadding,\r\n-              leading: widget.leading ?? _buildLeadingIcon(context),\r\n-              title: widget.title,\r\n-              subtitle: widget.subtitle,\r\n-              trailing: widget.trailing ?? _buildTrailingIcon(context),\r\n-            ),\r\n-          ),\r\n-          ClipRect(\r\n-            child: Align(\r\n-              alignment: widget.expandedAlignment ??\r\n-                  MYexpansionTileTheme.expandedAlignment ??\r\n-                  Alignment.center,\r\n-              heightFactor: _heightFactor.value,\r\n-              child: child,\r\n-            ),\r\n-          ),\r\n-        ],\r\n-      ),\r\n-    );\r\n-  }\r\n-\r\n-  @override\r\n-  void didChangeDependencies() {\r\n-    final ThemeData theme = Theme.of(context);\r\n-    final MYExpansionTileThemeData MYexpansionTileTheme =\r\n-        MYExpansionTileTheme.of(context);\r\n-    final MYExpansionTileThemeData defaults = theme.useMaterial3\r\n-        ? _MYExpansionTileDefaultsM3(context)\r\n-        : _MYExpansionTileDefaultsM2(context);\r\n-    _borderTween\r\n-      ..begin = widget.collapsedShape ??\r\n-          MYexpansionTileTheme.collapsedShape ??\r\n-          const Border(\r\n-            top: BorderSide(color: Colors.transparent),\r\n-            bottom: BorderSide(color: Colors.transparent),\r\n-          )\r\n-      ..end = widget.shape ??\r\n-          MYexpansionTileTheme.collapsedShape ??\r\n-          Border(\r\n-            top: BorderSide(color: theme.dividerColor),\r\n-            bottom: BorderSide(color: theme.dividerColor),\r\n-          );\r\n-    _headerColorTween\r\n-      ..begin = widget.collapsedTextColor ??\r\n-          MYexpansionTileTheme.collapsedTextColor ??\r\n-          defaults.collapsedTextColor\r\n-      ..end = widget.textColor ??\r\n-          MYexpansionTileTheme.textColor ??\r\n-          defaults.textColor;\r\n-    _iconColorTween\r\n-      ..begin = widget.collapsedIconColor ??\r\n-          MYexpansionTileTheme.collapsedIconColor ??\r\n-          defaults.collapsedIconColor\r\n-      ..end = widget.iconColor ??\r\n-          MYexpansionTileTheme.iconColor ??\r\n-          defaults.iconColor;\r\n-    _backgroundColorTween\r\n-      ..begin = widget.collapsedBackgroundColor ??\r\n-          MYexpansionTileTheme.collapsedBackgroundColor\r\n-      ..end = widget.backgroundColor ?? MYexpansionTileTheme.backgroundColor;\r\n-    super.didChangeDependencies();\r\n-  }\r\n-\r\n-  @override\r\n-  Widget build(BuildContext context) {\r\n-    final MYExpansionTileThemeData MYexpansionTileTheme =\r\n-        MYExpansionTileTheme.of(context);\r\n-    final bool closed = !_isExpanded && _animationController.isDismissed;\r\n-    final bool shouldRemoveChildren = closed && !widget.maintainState;\r\n-\r\n-    final Widget result = Offstage(\r\n-      offstage: closed,\r\n-      child: TickerMode(\r\n-        enabled: !closed,\r\n-        child: Padding(\r\n-          padding: widget.childrenPadding ??\r\n-              MYexpansionTileTheme.childrenPadding ??\r\n-              EdgeInsets.zero,\r\n-          child: Column(\r\n-            crossAxisAlignment:\r\n-                widget.expandedCrossAxisAlignment ?? CrossAxisAlignment.center,\r\n-            children: widget.children,\r\n-          ),\r\n-        ),\r\n-      ),\r\n-    );\r\n-\r\n-    return AnimatedBuilder(\r\n-      animation: _animationController.view,\r\n-      builder: _buildChildren,\r\n-      child: shouldRemoveChildren ? null : result,\r\n-    );\r\n-  }\r\n-}\r\n-\r\n-class _MYExpansionTileDefaultsM2 extends MYExpansionTileThemeData {\r\n-  _MYExpansionTileDefaultsM2(this.context);\r\n-\r\n-  final BuildContext context;\r\n-  late final ThemeData _theme = Theme.of(context);\r\n-  late final ColorScheme _colorScheme = _theme.colorScheme;\r\n-\r\n-  @override\r\n-  Color? get textColor => _colorScheme.primary;\r\n-\r\n-  @override\r\n-  Color? get iconColor => _colorScheme.primary;\r\n-\r\n-  @override\r\n-  Color? get collapsedTextColor => _theme.textTheme.titleMedium!.color;\r\n-\r\n-  @override\r\n-  Color? get collapsedIconColor => _theme.unselectedWidgetColor;\r\n-}\r\n-\r\n-// BEGIN GENERATED TOKEN PROPERTIES - MYExpansionTile\r\n-\r\n-// Do not edit by hand. The code between the \"BEGIN GENERATED\" and\r\n-// \"END GENERATED\" comments are generated from data in the Material\r\n-// Design token database by the script:\r\n-//   dev/tools/gen_defaults/bin/gen_defaults.dart.\r\n-\r\n-// Token database version: v0_162\r\n-\r\n-class _MYExpansionTileDefaultsM3 extends MYExpansionTileThemeData {\r\n-  _MYExpansionTileDefaultsM3(this.context);\r\n-\r\n-  final BuildContext context;\r\n-  late final ThemeData _theme = Theme.of(context);\r\n-  late final ColorScheme _colors = _theme.colorScheme;\r\n-\r\n-  @override\r\n-  Color? get textColor => _colors.onSurface;\r\n-\r\n-  @override\r\n-  Color? get iconColor => _colors.primary;\r\n-\r\n-  @override\r\n-  Color? get collapsedTextColor => _colors.onSurface;\r\n-\r\n-  @override\r\n-  Color? get collapsedIconColor => _colors.onSurfaceVariant;\r\n-}\r\n-\r\n-// END GENERATED TOKEN PROPERTIES - MYExpansionTile\r\n\\ No newline at end of file\n"
                }
            ],
            "date": 1694523077362,
            "name": "Commit-0",
            "content": "// Copyright 2014 The Flutter Authors. All rights reserved.\r\n// Use of this source code is governed by a BSD-style license that can be\r\n// found in the LICENSE file.\r\n\r\nimport 'package:flutter/widgets.dart';\r\n\r\nimport 'color_scheme.dart';\r\nimport 'colors.dart';\r\nimport 'expansion_tile_theme.dart';\r\nimport 'icons.dart';\r\nimport 'list_tile.dart';\r\nimport 'list_tile_theme.dart';\r\nimport 'material.dart';\r\nimport 'theme.dart';\r\n\r\nconst Duration _kExpand = Duration(milliseconds: 200);\r\n\r\n/// Enables control over a single [ExpansionTile]'s expanded/collapsed state.\r\n///\r\n/// It can be useful to expand or collapse an [ExpansionTile]\r\n/// programatically, for example to reconfigure an existing expansion\r\n/// tile based on a system event. To do so, create an [ExpansionTile]\r\n/// with an [ExpansionTileController] that's owned by a stateful widget\r\n/// or look up the tile's automatically created [ExpansionTileController]\r\n/// with [ExpansionTileController.of]\r\n///\r\n/// The controller's [expand] and [collapse] methods cause the\r\n/// the [ExpansionTile] to rebuild, so they may not be called from\r\n/// a build method.\r\nclass ExpansionTileController {\r\n  /// Create a controller to be used with [ExpansionTile.controller].\r\n  ExpansionTileController();\r\n\r\n  _ExpansionTileState? _state;\r\n\r\n  /// Whether the [ExpansionTile] built with this controller is in expanded state.\r\n  ///\r\n  /// This property doesn't take the animation into account. It reports `true`\r\n  /// even if the expansion animation is not completed.\r\n  ///\r\n  /// See also:\r\n  ///\r\n  ///  * [expand], which expands the [ExpansionTile].\r\n  ///  * [collapse], which collapses the [ExpansionTile].\r\n  ///  * [ExpansionTile.controller] to create an ExpansionTile with a controller.\r\n  bool get isExpanded {\r\n    assert(_state != null);\r\n    return _state!._isExpanded;\r\n  }\r\n\r\n  /// Expands the [ExpansionTile] that was built with this controller;\r\n  ///\r\n  /// Normally the tile is expanded automatically when the user taps on the header.\r\n  /// It is sometimes useful to trigger the expansion programmatically due\r\n  /// to external changes.\r\n  ///\r\n  /// If the tile is already in the expanded state (see [isExpanded]), calling\r\n  /// this method has no effect.\r\n  ///\r\n  /// Calling this method may cause the [ExpansionTile] to rebuild, so it may\r\n  /// not be called from a build method.\r\n  ///\r\n  /// Calling this method will trigger an [ExpansionTile.onExpansionChanged] callback.\r\n  ///\r\n  /// See also:\r\n  ///\r\n  ///  * [collapse], which collapses the tile.\r\n  ///  * [isExpanded] to check whether the tile is expanded.\r\n  ///  * [ExpansionTile.controller] to create an ExpansionTile with a controller.\r\n  void expand() {\r\n    assert(_state != null);\r\n    if (!isExpanded) {\r\n      _state!._toggleExpansion();\r\n    }\r\n  }\r\n\r\n  /// Collapses the [ExpansionTile] that was built with this controller.\r\n  ///\r\n  /// Normally the tile is collapsed automatically when the user taps on the header.\r\n  /// It can be useful sometimes to trigger the collapse programmatically due\r\n  /// to some external changes.\r\n  ///\r\n  /// If the tile is already in the collapsed state (see [isExpanded]), calling\r\n  /// this method has no effect.\r\n  ///\r\n  /// Calling this method may cause the [ExpansionTile] to rebuild, so it may\r\n  /// not be called from a build method.\r\n  ///\r\n  /// Calling this method will trigger an [ExpansionTile.onExpansionChanged] callback.\r\n  ///\r\n  /// See also:\r\n  ///\r\n  ///  * [expand], which expands the tile.\r\n  ///  * [isExpanded] to check whether the tile is expanded.\r\n  ///  * [ExpansionTile.controller] to create an ExpansionTile with a controller.\r\n  void collapse() {\r\n    assert(_state != null);\r\n    if (isExpanded) {\r\n      _state!._toggleExpansion();\r\n    }\r\n  }\r\n\r\n  /// Finds the [ExpansionTileController] for the closest [ExpansionTile] instance\r\n  /// that encloses the given context.\r\n  ///\r\n  /// If no [ExpansionTile] encloses the given context, calling this\r\n  /// method will cause an assert in debug mode, and throw an\r\n  /// exception in release mode.\r\n  ///\r\n  /// To return null if there is no [ExpansionTile] use [maybeOf] instead.\r\n  ///\r\n  /// {@tool dartpad}\r\n  /// Typical usage of the [ExpansionTileController.of] function is to call it from within the\r\n  /// `build` method of a descendant of an [ExpansionTile].\r\n  ///\r\n  /// When the [ExpansionTile] is actually created in the same `build`\r\n  /// function as the callback that refers to the controller, then the\r\n  /// `context` argument to the `build` function can't be used to find\r\n  /// the [ExpansionTileController] (since it's \"above\" the widget\r\n  /// being returned in the widget tree). In cases like that you can\r\n  /// add a [Builder] widget, which provides a new scope with a\r\n  /// [BuildContext] that is \"under\" the [ExpansionTile]:\r\n  ///\r\n  /// ** See code in examples/api/lib/material/expansion_tile/expansion_tile.1.dart **\r\n  /// {@end-tool}\r\n  ///\r\n  /// A more efficient solution is to split your build function into\r\n  /// several widgets. This introduces a new context from which you\r\n  /// can obtain the [ExpansionTileController]. With this approach you\r\n  /// would have an outer widget that creates the [ExpansionTile]\r\n  /// populated by instances of your new inner widgets, and then in\r\n  /// these inner widgets you would use [ExpansionTileController.of].\r\n  static ExpansionTileController of(BuildContext context) {\r\n    final _ExpansionTileState? result =\r\n        context.findAncestorStateOfType<_ExpansionTileState>();\r\n    if (result != null) {\r\n      return result._tileController;\r\n    }\r\n    throw FlutterError.fromParts(<DiagnosticsNode>[\r\n      ErrorSummary(\r\n        'ExpansionTileController.of() called with a context that does not contain a ExpansionTile.',\r\n      ),\r\n      ErrorDescription(\r\n        'No ExpansionTile ancestor could be found starting from the context that was passed to ExpansionTileController.of(). '\r\n        'This usually happens when the context provided is from the same StatefulWidget as that '\r\n        'whose build function actually creates the ExpansionTile widget being sought.',\r\n      ),\r\n      ErrorHint(\r\n        'There are several ways to avoid this problem. The simplest is to use a Builder to get a '\r\n        'context that is \"under\" the ExpansionTile. For an example of this, please see the '\r\n        'documentation for ExpansionTileController.of():\\n'\r\n        '  https://api.flutter.dev/flutter/material/ExpansionTile/of.html',\r\n      ),\r\n      ErrorHint(\r\n        'A more efficient solution is to split your build function into several widgets. This '\r\n        'introduces a new context from which you can obtain the ExpansionTile. In this solution, '\r\n        'you would have an outer widget that creates the ExpansionTile populated by instances of '\r\n        'your new inner widgets, and then in these inner widgets you would use ExpansionTileController.of().\\n'\r\n        'An other solution is assign a GlobalKey to the ExpansionTile, '\r\n        'then use the key.currentState property to obtain the ExpansionTile rather than '\r\n        'using the ExpansionTileController.of() function.',\r\n      ),\r\n      context.describeElement('The context used was'),\r\n    ]);\r\n  }\r\n\r\n  /// Finds the [ExpansionTile] from the closest instance of this class that\r\n  /// encloses the given context and returns its [ExpansionTileController].\r\n  ///\r\n  /// If no [ExpansionTile] encloses the given context then return null.\r\n  /// To throw an exception instead, use [of] instead of this function.\r\n  ///\r\n  /// See also:\r\n  ///\r\n  ///  * [of], a similar function to this one that throws if no [ExpansionTile]\r\n  ///    encloses the given context. Also includes some sample code in its\r\n  ///    documentation.\r\n  static ExpansionTileController? maybeOf(BuildContext context) {\r\n    return context\r\n        .findAncestorStateOfType<_ExpansionTileState>()\r\n        ?._tileController;\r\n  }\r\n}\r\n\r\n/// A single-line [ListTile] with an expansion arrow icon that expands or collapses\r\n/// the tile to reveal or hide the [children].\r\n///\r\n/// This widget is typically used with [ListView] to create an\r\n/// \"expand / collapse\" list entry. When used with scrolling widgets like\r\n/// [ListView], a unique [PageStorageKey] must be specified to enable the\r\n/// [ExpansionTile] to save and restore its expanded state when it is scrolled\r\n/// in and out of view.\r\n///\r\n/// This class overrides the [ListTileThemeData.iconColor] and [ListTileThemeData.textColor]\r\n/// theme properties for its [ListTile]. These colors animate between values when\r\n/// the tile is expanded and collapsed: between [iconColor], [collapsedIconColor] and\r\n/// between [textColor] and [collapsedTextColor].\r\n///\r\n/// The expansion arrow icon is shown on the right by default in left-to-right languages\r\n/// (i.e. the trailing edge). This can be changed using [controlAffinity]. This maps\r\n/// to the [leading] and [trailing] properties of [ExpansionTile].\r\n///\r\n/// {@tool dartpad}\r\n/// This example demonstrates how the [ExpansionTile] icon's location and appearance\r\n/// can be customized.\r\n///\r\n/// ** See code in examples/api/lib/material/expansion_tile/expansion_tile.0.dart **\r\n/// {@end-tool}\r\n///\r\n/// {@tool dartpad}\r\n/// This example demonstrates how an [ExpansionTileController] can be used to\r\n/// programatically expand or collapse an [ExpansionTile].\r\n///\r\n/// ** See code in examples/api/lib/material/expansion_tile/expansion_tile.1.dart **\r\n/// {@end-tool}\r\n///\r\n/// See also:\r\n///\r\n///  * [ListTile], useful for creating expansion tile [children] when the\r\n///    expansion tile represents a sublist.\r\n///  * The \"Expand and collapse\" section of\r\n///    <https://material.io/components/lists#types>\r\nclass ExpansionTile extends StatefulWidget {\r\n  /// Creates a single-line [ListTile] with an expansion arrow icon that expands or collapses\r\n  /// the tile to reveal or hide the [children]. The [initiallyExpanded] property must\r\n  /// be non-null.\r\n  const ExpansionTile({\r\n    super.key,\r\n    this.leading,\r\n    required this.title,\r\n    this.subtitle,\r\n    this.onExpansionChanged,\r\n    this.children = const <Widget>[],\r\n    this.trailing,\r\n    this.initiallyExpanded = false,\r\n    this.maintainState = false,\r\n    this.tilePadding,\r\n    this.expandedCrossAxisAlignment,\r\n    this.expandedAlignment,\r\n    this.childrenPadding,\r\n    this.backgroundColor,\r\n    this.collapsedBackgroundColor,\r\n    this.textColor,\r\n    this.collapsedTextColor,\r\n    this.iconColor,\r\n    this.collapsedIconColor,\r\n    this.shape,\r\n    this.collapsedShape,\r\n    this.clipBehavior,\r\n    this.controlAffinity,\r\n    this.controller,\r\n  }) : assert(\r\n          expandedCrossAxisAlignment != CrossAxisAlignment.baseline,\r\n          'CrossAxisAlignment.baseline is not supported since the expanded children '\r\n          'are aligned in a column, not a row. Try to use another constant.',\r\n        );\r\n\r\n  /// A widget to display before the title.\r\n  ///\r\n  /// Typically a [CircleAvatar] widget.\r\n  ///\r\n  /// Depending on the value of [controlAffinity], the [leading] widget\r\n  /// may replace the rotating expansion arrow icon.\r\n  final Widget? leading;\r\n\r\n  /// The primary content of the list item.\r\n  ///\r\n  /// Typically a [Text] widget.\r\n  final Widget title;\r\n\r\n  /// Additional content displayed below the title.\r\n  ///\r\n  /// Typically a [Text] widget.\r\n  final Widget? subtitle;\r\n\r\n  /// Called when the tile expands or collapses.\r\n  ///\r\n  /// When the tile starts expanding, this function is called with the value\r\n  /// true. When the tile starts collapsing, this function is called with\r\n  /// the value false.\r\n  final ValueChanged<bool>? onExpansionChanged;\r\n\r\n  /// The widgets that are displayed when the tile expands.\r\n  ///\r\n  /// Typically [ListTile] widgets.\r\n  final List<Widget> children;\r\n\r\n  /// The color to display behind the sublist when expanded.\r\n  ///\r\n  /// If this property is null then [ExpansionTileThemeData.backgroundColor] is used. If that\r\n  /// is also null then Colors.transparent is used.\r\n  ///\r\n  /// See also:\r\n  ///\r\n  /// * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s\r\n  ///   [ExpansionTileThemeData].\r\n  final Color? backgroundColor;\r\n\r\n  /// When not null, defines the background color of tile when the sublist is collapsed.\r\n  ///\r\n  /// If this property is null then [ExpansionTileThemeData.collapsedBackgroundColor] is used.\r\n  /// If that is also null then Colors.transparent is used.\r\n  ///\r\n  /// See also:\r\n  ///\r\n  /// * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s\r\n  ///   [ExpansionTileThemeData].\r\n  final Color? collapsedBackgroundColor;\r\n\r\n  /// A widget to display after the title.\r\n  ///\r\n  /// Depending on the value of [controlAffinity], the [trailing] widget\r\n  /// may replace the rotating expansion arrow icon.\r\n  final Widget? trailing;\r\n\r\n  /// Specifies if the list tile is initially expanded (true) or collapsed (false, the default).\r\n  final bool initiallyExpanded;\r\n\r\n  /// Specifies whether the state of the children is maintained when the tile expands and collapses.\r\n  ///\r\n  /// When true, the children are kept in the tree while the tile is collapsed.\r\n  /// When false (default), the children are removed from the tree when the tile is\r\n  /// collapsed and recreated upon expansion.\r\n  final bool maintainState;\r\n\r\n  /// Specifies padding for the [ListTile].\r\n  ///\r\n  /// Analogous to [ListTile.contentPadding], this property defines the insets for\r\n  /// the [leading], [title], [subtitle] and [trailing] widgets. It does not inset\r\n  /// the expanded [children] widgets.\r\n  ///\r\n  /// If this property is null then [ExpansionTileThemeData.tilePadding] is used. If that\r\n  /// is also null then the tile's padding is `EdgeInsets.symmetric(horizontal: 16.0)`.\r\n  ///\r\n  /// See also:\r\n  ///\r\n  /// * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s\r\n  ///   [ExpansionTileThemeData].\r\n  final EdgeInsetsGeometry? tilePadding;\r\n\r\n  /// Specifies the alignment of [children], which are arranged in a column when\r\n  /// the tile is expanded.\r\n  ///\r\n  /// The internals of the expanded tile make use of a [Column] widget for\r\n  /// [children], and [Align] widget to align the column. The [expandedAlignment]\r\n  /// parameter is passed directly into the [Align].\r\n  ///\r\n  /// Modifying this property controls the alignment of the column within the\r\n  /// expanded tile, not the alignment of [children] widgets within the column.\r\n  /// To align each child within [children], see [expandedCrossAxisAlignment].\r\n  ///\r\n  /// The width of the column is the width of the widest child widget in [children].\r\n  ///\r\n  /// If this property is null then [ExpansionTileThemeData.expandedAlignment]is used. If that\r\n  /// is also null then the value of [expandedAlignment] is [Alignment.center].\r\n  ///\r\n  /// See also:\r\n  ///\r\n  /// * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s\r\n  ///   [ExpansionTileThemeData].\r\n  final Alignment? expandedAlignment;\r\n\r\n  /// Specifies the alignment of each child within [children] when the tile is expanded.\r\n  ///\r\n  /// The internals of the expanded tile make use of a [Column] widget for\r\n  /// [children], and the `crossAxisAlignment` parameter is passed directly into\r\n  /// the [Column].\r\n  ///\r\n  /// Modifying this property controls the cross axis alignment of each child\r\n  /// within its [Column]. The width of the [Column] that houses [children] will\r\n  /// be the same as the widest child widget in [children]. The width of the\r\n  /// [Column] might not be equal to the width of the expanded tile.\r\n  ///\r\n  /// To align the [Column] along the expanded tile, use the [expandedAlignment]\r\n  /// property instead.\r\n  ///\r\n  /// When the value is null, the value of [expandedCrossAxisAlignment] is\r\n  /// [CrossAxisAlignment.center].\r\n  final CrossAxisAlignment? expandedCrossAxisAlignment;\r\n\r\n  /// Specifies padding for [children].\r\n  ///\r\n  /// If this property is null then [ExpansionTileThemeData.childrenPadding] is used. If that\r\n  /// is also null then the value of [childrenPadding] is [EdgeInsets.zero].\r\n  ///\r\n  /// See also:\r\n  ///\r\n  /// * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s\r\n  ///   [ExpansionTileThemeData].\r\n  final EdgeInsetsGeometry? childrenPadding;\r\n\r\n  /// The icon color of tile's expansion arrow icon when the sublist is expanded.\r\n  ///\r\n  /// Used to override to the [ListTileThemeData.iconColor].\r\n  ///\r\n  /// If this property is null then [ExpansionTileThemeData.iconColor] is used. If that\r\n  /// is also null then the value of [ColorScheme.primary] is used.\r\n  ///\r\n  /// See also:\r\n  ///\r\n  /// * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s\r\n  ///   [ExpansionTileThemeData].\r\n  final Color? iconColor;\r\n\r\n  /// The icon color of tile's expansion arrow icon when the sublist is collapsed.\r\n  ///\r\n  /// Used to override to the [ListTileThemeData.iconColor].\r\n  ///\r\n  /// If this property is null then [ExpansionTileThemeData.collapsedIconColor] is used. If that\r\n  /// is also null and [ThemeData.useMaterial3] is true, [ColorScheme.onSurface] is used. Otherwise,\r\n  /// defaults to [ThemeData.unselectedWidgetColor] color.\r\n  ///\r\n  /// See also:\r\n  ///\r\n  /// * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s\r\n  ///   [ExpansionTileThemeData].\r\n  final Color? collapsedIconColor;\r\n\r\n  /// The color of the tile's titles when the sublist is expanded.\r\n  ///\r\n  /// Used to override to the [ListTileThemeData.textColor].\r\n  ///\r\n  /// If this property is null then [ExpansionTileThemeData.textColor] is used. If that\r\n  /// is also null then and [ThemeData.useMaterial3] is true, color of the [TextTheme.bodyLarge]\r\n  /// will be used for the [title] and [subtitle]. Otherwise, defaults to [ColorScheme.primary] color.\r\n  ///\r\n  /// See also:\r\n  ///\r\n  /// * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s\r\n  ///   [ExpansionTileThemeData].\r\n  final Color? textColor;\r\n\r\n  /// The color of the tile's titles when the sublist is collapsed.\r\n  ///\r\n  /// Used to override to the [ListTileThemeData.textColor].\r\n  ///\r\n  /// If this property is null then [ExpansionTileThemeData.collapsedTextColor] is used.\r\n  /// If that is also null and [ThemeData.useMaterial3] is true, color of the\r\n  /// [TextTheme.bodyLarge] will be used for the [title] and [subtitle]. Otherwise,\r\n  /// defaults to color of the [TextTheme.titleMedium].\r\n  ///\r\n  /// See also:\r\n  ///\r\n  /// * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s\r\n  ///   [ExpansionTileThemeData].\r\n  final Color? collapsedTextColor;\r\n\r\n  /// The tile's border shape when the sublist is expanded.\r\n  ///\r\n  /// If this property is null, the [ExpansionTileThemeData.shape] is used. If that\r\n  /// is also null, a [Border] with vertical sides default to [ThemeData.dividerColor] is used\r\n  ///\r\n  /// See also:\r\n  ///\r\n  /// * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s\r\n  ///   [ExpansionTileThemeData].\r\n  final ShapeBorder? shape;\r\n\r\n  /// The tile's border shape when the sublist is collapsed.\r\n  ///\r\n  /// If this property is null, the [ExpansionTileThemeData.collapsedShape] is used. If that\r\n  /// is also null, a [Border] with vertical sides default to Color [Colors.transparent] is used\r\n  ///\r\n  /// See also:\r\n  ///\r\n  /// * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s\r\n  ///   [ExpansionTileThemeData].\r\n  final ShapeBorder? collapsedShape;\r\n\r\n  /// {@macro flutter.material.Material.clipBehavior}\r\n  ///\r\n  /// If this property is null, the [ExpansionTileThemeData.clipBehavior] is used. If that\r\n  /// is also null, a [Clip.none] is used\r\n  ///\r\n  /// See also:\r\n  ///\r\n  /// * [ExpansionTileTheme.of], which returns the nearest [ExpansionTileTheme]'s\r\n  ///   [ExpansionTileThemeData].\r\n  final Clip? clipBehavior;\r\n\r\n  /// Typically used to force the expansion arrow icon to the tile's leading or trailing edge.\r\n  ///\r\n  /// By default, the value of [controlAffinity] is [ListTileControlAffinity.platform],\r\n  /// which means that the expansion arrow icon will appear on the tile's trailing edge.\r\n  final ListTileControlAffinity? controlAffinity;\r\n\r\n  /// If provided, the controller can be used to expand and collapse tiles.\r\n  ///\r\n  /// In cases were control over the tile's state is needed from a callback triggered\r\n  /// by a widget within the tile, [ExpansionTileController.of] may be more convenient\r\n  /// than supplying a controller.\r\n  final ExpansionTileController? controller;\r\n\r\n  @override\r\n  State<ExpansionTile> createState() => _ExpansionTileState();\r\n}\r\n\r\nclass _ExpansionTileState extends State<ExpansionTile>\r\n    with SingleTickerProviderStateMixin {\r\n  static final Animatable<double> _easeOutTween =\r\n      CurveTween(curve: Curves.easeOut);\r\n  static final Animatable<double> _easeInTween =\r\n      CurveTween(curve: Curves.easeIn);\r\n  static final Animatable<double> _halfTween =\r\n      Tween<double>(begin: 0.0, end: 0.5);\r\n\r\n  final ShapeBorderTween _borderTween = ShapeBorderTween();\r\n  final ColorTween _headerColorTween = ColorTween();\r\n  final ColorTween _iconColorTween = ColorTween();\r\n  final ColorTween _backgroundColorTween = ColorTween();\r\n\r\n  late AnimationController _animationController;\r\n  late Animation<double> _iconTurns;\r\n  late Animation<double> _heightFactor;\r\n  late Animation<ShapeBorder?> _border;\r\n  late Animation<Color?> _headerColor;\r\n  late Animation<Color?> _iconColor;\r\n  late Animation<Color?> _backgroundColor;\r\n\r\n  bool _isExpanded = false;\r\n  late ExpansionTileController _tileController;\r\n\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    _animationController = AnimationController(duration: _kExpand, vsync: this);\r\n    _heightFactor = _animationController.drive(_easeInTween);\r\n    _iconTurns = _animationController.drive(_halfTween.chain(_easeInTween));\r\n    _border = _animationController.drive(_borderTween.chain(_easeOutTween));\r\n    _headerColor =\r\n        _animationController.drive(_headerColorTween.chain(_easeInTween));\r\n    _iconColor =\r\n        _animationController.drive(_iconColorTween.chain(_easeInTween));\r\n    _backgroundColor =\r\n        _animationController.drive(_backgroundColorTween.chain(_easeOutTween));\r\n\r\n    _isExpanded = PageStorage.maybeOf(context)?.readState(context) as bool? ??\r\n        widget.initiallyExpanded;\r\n    if (_isExpanded) {\r\n      _animationController.value = 1.0;\r\n    }\r\n\r\n    assert(widget.controller?._state == null);\r\n    _tileController = widget.controller ?? ExpansionTileController();\r\n    _tileController._state = this;\r\n  }\r\n\r\n  @override\r\n  void dispose() {\r\n    _tileController._state = null;\r\n    _animationController.dispose();\r\n    super.dispose();\r\n  }\r\n\r\n  void _toggleExpansion() {\r\n    setState(() {\r\n      _isExpanded = !_isExpanded;\r\n      if (_isExpanded) {\r\n        _animationController.forward();\r\n      } else {\r\n        _animationController.reverse().then<void>((void value) {\r\n          if (!mounted) {\r\n            return;\r\n          }\r\n          setState(() {\r\n            // Rebuild without widget.children.\r\n          });\r\n        });\r\n      }\r\n      PageStorage.maybeOf(context)?.writeState(context, _isExpanded);\r\n    });\r\n    widget.onExpansionChanged?.call(_isExpanded);\r\n  }\r\n\r\n  void _handleTap() {\r\n    _toggleExpansion();\r\n  }\r\n\r\n  // Platform or null affinity defaults to trailing.\r\n  ListTileControlAffinity _effectiveAffinity(\r\n      ListTileControlAffinity? affinity) {\r\n    switch (affinity ?? ListTileControlAffinity.trailing) {\r\n      case ListTileControlAffinity.leading:\r\n        return ListTileControlAffinity.leading;\r\n      case ListTileControlAffinity.trailing:\r\n      case ListTileControlAffinity.platform:\r\n        return ListTileControlAffinity.trailing;\r\n    }\r\n  }\r\n\r\n  Widget? _buildIcon(BuildContext context) {\r\n    return RotationTransition(\r\n      turns: _iconTurns,\r\n      child: const Icon(Icons.expand_more),\r\n    );\r\n  }\r\n\r\n  Widget? _buildLeadingIcon(BuildContext context) {\r\n    if (_effectiveAffinity(widget.controlAffinity) !=\r\n        ListTileControlAffinity.leading) {\r\n      return null;\r\n    }\r\n    return _buildIcon(context);\r\n  }\r\n\r\n  Widget? _buildTrailingIcon(BuildContext context) {\r\n    if (_effectiveAffinity(widget.controlAffinity) !=\r\n        ListTileControlAffinity.trailing) {\r\n      return null;\r\n    }\r\n    return _buildIcon(context);\r\n  }\r\n\r\n  Widget _buildChildren(BuildContext context, Widget? child) {\r\n    final ExpansionTileThemeData expansionTileTheme =\r\n        ExpansionTileTheme.of(context);\r\n    final ShapeBorder expansionTileBorder = _border.value ??\r\n        const Border(\r\n          top: BorderSide(color: Colors.transparent),\r\n          bottom: BorderSide(color: Colors.transparent),\r\n        );\r\n    final Clip clipBehavior =\r\n        widget.clipBehavior ?? expansionTileTheme.clipBehavior ?? Clip.none;\r\n\r\n    return Container(\r\n      clipBehavior: clipBehavior,\r\n      decoration: ShapeDecoration(\r\n        color: _backgroundColor.value ??\r\n            expansionTileTheme.backgroundColor ??\r\n            Colors.transparent,\r\n        shape: expansionTileBorder,\r\n      ),\r\n      child: Column(\r\n        mainAxisSize: MainAxisSize.min,\r\n        children: <Widget>[\r\n          ListTileTheme.merge(\r\n            iconColor: _iconColor.value ?? expansionTileTheme.iconColor,\r\n            textColor: _headerColor.value,\r\n            child: ListTile(\r\n              onTap: _handleTap,\r\n              contentPadding:\r\n                  widget.tilePadding ?? expansionTileTheme.tilePadding,\r\n              leading: widget.leading ?? _buildLeadingIcon(context),\r\n              title: widget.title,\r\n              subtitle: widget.subtitle,\r\n              trailing: widget.trailing ?? _buildTrailingIcon(context),\r\n            ),\r\n          ),\r\n          ClipRect(\r\n            child: Align(\r\n              alignment: widget.expandedAlignment ??\r\n                  expansionTileTheme.expandedAlignment ??\r\n                  Alignment.center,\r\n              heightFactor: _heightFactor.value,\r\n              child: child,\r\n            ),\r\n          ),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n\r\n  @override\r\n  void didChangeDependencies() {\r\n    final ThemeData theme = Theme.of(context);\r\n    final ExpansionTileThemeData expansionTileTheme =\r\n        ExpansionTileTheme.of(context);\r\n    final ExpansionTileThemeData defaults = theme.useMaterial3\r\n        ? _ExpansionTileDefaultsM3(context)\r\n        : _ExpansionTileDefaultsM2(context);\r\n    _borderTween\r\n      ..begin = widget.collapsedShape ??\r\n          expansionTileTheme.collapsedShape ??\r\n          const Border(\r\n            top: BorderSide(color: Colors.transparent),\r\n            bottom: BorderSide(color: Colors.transparent),\r\n          )\r\n      ..end = widget.shape ??\r\n          expansionTileTheme.collapsedShape ??\r\n          Border(\r\n            top: BorderSide(color: theme.dividerColor),\r\n            bottom: BorderSide(color: theme.dividerColor),\r\n          );\r\n    _headerColorTween\r\n      ..begin = widget.collapsedTextColor ??\r\n          expansionTileTheme.collapsedTextColor ??\r\n          defaults.collapsedTextColor\r\n      ..end = widget.textColor ??\r\n          expansionTileTheme.textColor ??\r\n          defaults.textColor;\r\n    _iconColorTween\r\n      ..begin = widget.collapsedIconColor ??\r\n          expansionTileTheme.collapsedIconColor ??\r\n          defaults.collapsedIconColor\r\n      ..end = widget.iconColor ??\r\n          expansionTileTheme.iconColor ??\r\n          defaults.iconColor;\r\n    _backgroundColorTween\r\n      ..begin = widget.collapsedBackgroundColor ??\r\n          expansionTileTheme.collapsedBackgroundColor\r\n      ..end = widget.backgroundColor ?? expansionTileTheme.backgroundColor;\r\n    super.didChangeDependencies();\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    final ExpansionTileThemeData expansionTileTheme =\r\n        ExpansionTileTheme.of(context);\r\n    final bool closed = !_isExpanded && _animationController.isDismissed;\r\n    final bool shouldRemoveChildren = closed && !widget.maintainState;\r\n\r\n    final Widget result = Offstage(\r\n      offstage: closed,\r\n      child: TickerMode(\r\n        enabled: !closed,\r\n        child: Padding(\r\n          padding: widget.childrenPadding ??\r\n              expansionTileTheme.childrenPadding ??\r\n              EdgeInsets.zero,\r\n          child: Column(\r\n            crossAxisAlignment:\r\n                widget.expandedCrossAxisAlignment ?? CrossAxisAlignment.center,\r\n            children: widget.children,\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n\r\n    return AnimatedBuilder(\r\n      animation: _animationController.view,\r\n      builder: _buildChildren,\r\n      child: shouldRemoveChildren ? null : result,\r\n    );\r\n  }\r\n}\r\n\r\nclass _ExpansionTileDefaultsM2 extends ExpansionTileThemeData {\r\n  _ExpansionTileDefaultsM2(this.context);\r\n\r\n  final BuildContext context;\r\n  late final ThemeData _theme = Theme.of(context);\r\n  late final ColorScheme _colorScheme = _theme.colorScheme;\r\n\r\n  @override\r\n  Color? get textColor => _colorScheme.primary;\r\n\r\n  @override\r\n  Color? get iconColor => _colorScheme.primary;\r\n\r\n  @override\r\n  Color? get collapsedTextColor => _theme.textTheme.titleMedium!.color;\r\n\r\n  @override\r\n  Color? get collapsedIconColor => _theme.unselectedWidgetColor;\r\n}\r\n\r\n// BEGIN GENERATED TOKEN PROPERTIES - ExpansionTile\r\n\r\n// Do not edit by hand. The code between the \"BEGIN GENERATED\" and\r\n// \"END GENERATED\" comments are generated from data in the Material\r\n// Design token database by the script:\r\n//   dev/tools/gen_defaults/bin/gen_defaults.dart.\r\n\r\n// Token database version: v0_162\r\n\r\nclass _ExpansionTileDefaultsM3 extends ExpansionTileThemeData {\r\n  _ExpansionTileDefaultsM3(this.context);\r\n\r\n  final BuildContext context;\r\n  late final ThemeData _theme = Theme.of(context);\r\n  late final ColorScheme _colors = _theme.colorScheme;\r\n\r\n  @override\r\n  Color? get textColor => _colors.onSurface;\r\n\r\n  @override\r\n  Color? get iconColor => _colors.primary;\r\n\r\n  @override\r\n  Color? get collapsedTextColor => _colors.onSurface;\r\n\r\n  @override\r\n  Color? get collapsedIconColor => _colors.onSurfaceVariant;\r\n}\r\n\r\n// END GENERATED TOKEN PROPERTIES - ExpansionTile\r\n"
        }
    ]
}